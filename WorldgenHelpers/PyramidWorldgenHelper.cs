using Terraria.ID;
using System.Diagnostics;
using Terraria;
using Terraria.ModLoader;
using SOTS.Items.Otherworld;
using Microsoft.Xna.Framework;
using SOTS.Items.Pyramid;
using SOTS.Items.ChestItems;
using System;
using SOTS.Items;
using SOTS.Items.Pyramid;
using SOTS.Items.Pyramid.PyramidWalls;
using SOTS.Items.Pyramid.AltPyramidBlocks;
using SOTS.Items.Secrets;
using SOTS.Items.Fishing;
using SOTS.Items.Furniture.AncientGold;

namespace SOTS.WorldgenHelpers
{
	public class PyramidWorldgenHelper
	{
		public static void GenerateBossRoom(int spawnX, int spawnY, int direction = 1)
		{
			int[,] _structure = {
				{0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,3,2,2,2,0,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,2,2,0,2,3,2,3,2,2,0,2,2,0,2,2,3,3,2,2,2,2,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,2,2,0,2,3,2,3,3,2,0,2,2,0,2,3,3,3,2,3,3,0,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,0,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,2,3,3,3,3,3,3,2,0,0,2,0,2,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,2,3,3,2,2,2,3,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,4,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,4,4,4,4,4,4,3,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,3,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,3,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,3,4,4,4,4,4,4,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,4,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
				{0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,4,4,4,4,4,4,4,4,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,0,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,0,7,3,3,3,3,3,3,3,3,2,7,6,6,7,3,3,3,2,3,3,3,3,0,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,0,7,3,3,3,3,3,3,3,2,2,7,6,6,7,2,2,3,2,3,3,2,3,0,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,7,0,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,0,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,2,2,7,6,6,7,2,2,2,2,3,3,2,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,2,3,3,2,2,7,6,6,7,2,2,2,2,2,2,2,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,2,2,2,2,2,7,6,6,7,2,2,2,2,2,2,2,2,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
				{0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,3,3,3,7,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,7,6,6,6,6,6,6,6,6,6,7,6,6,6,6,6,6,6,6,6,7,6,6,6,6,6,6,6,6,6,7,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,6,6,6,6,6,6,6,6,6,7,6,6,6,6,6,6,6,6,6,7,6,6,6,6,6,6,6,6,6,7,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			int PosX = spawnX - _structure.GetLength(1) / 2;  //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = spawnY - _structure.GetLength(0) / 2;
			//i = vertical, j = horizontal
			for (int i = 0; i < _structure.GetLength(0); i++)
			{
				for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
				{
					int k = PosX + j;
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						switch (_structure[i, j])
						{
							case 0:
								if (tile.WallType == 0)
									tile.WallType = (ushort)ModContent.WallType<UnsafePyramidWallWall>();
								break;
							case 1:
								tile.WallType = 197;
								break;
							case 2:
								tile.WallType = (ushort)ModContent.WallType<UnsafeCursedTumorWallWall>();
								break;
							case 3:
								tile.WallType = (ushort)ModContent.WallType<UnsafePyramidWallWall>();
								break;
							case 4:
								tile.WallType = (ushort)ModContent.WallType<AncientGoldBrickWallTile>();
								break;
							case 5:
								tile.WallType = (ushort)ModContent.WallType<TrueSandstoneWallWall>();
								break;
							case 6:
								tile.WallType = WallID.ArcaneRunes;
								break;
							case 7:
								tile.WallType = (ushort)ModContent.WallType<AncientGoldBeamWall>();
								break;
						}
					}
				}
			}
			_structure = new int[,]  {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,2,2,2,2,3,4,5,2,2,2,2,2,2,2,3,4,4,5,2,2,2,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,2,2,2,3,4,4,5,2,2,2,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,5,2,2,3,4,4,4,4,5,2,2,2,2,3,4,4,4,4,4,2,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,2,2,4,4,4,4,5,2,2,4,4,4,4,5,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,5,2,4,4,4,4,4,4,2,2,2,2,4,4,4,4,4,4,5,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,3,4,4,4,4,4,2,2,4,4,4,4,4,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,2,4,4,4,4,4,4,2,2,2,3,4,4,4,4,4,4,4,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,4,4,4,4,4,4,2,3,4,4,4,4,4,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,4,4,4,4,4,4,4,2,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,4,4,4,4,4,4,4,5,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0},
				{0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0},
				{0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,4,4,4,4,4,4,8,8,4,4,4,4,4,8,8,8,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,4,4,4,4,4,4,4,4,4,4,8,8,4,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0},
				{0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,8,8,8,8,4,4,8,8,8,8,8,4,4,8,8,8,8,8,8,8,4,8,8,8,8,8,8,4,4,6,4,4,4,7,4,4,6,4,4,4,8,8,8,8,8,8,8,4,4,4,4,8,8,8,8,8,8,8,4,8,8,8,8,8,8,8,8,8,8,8,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0},
				{1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,10,9,9,9,9,9,9,10,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,9,9,9,1,1,1,1,1},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,14,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,21,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,13,4,15,4,4,13,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,21,4,4},
				{1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1},
				{0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0},
				{0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,2,2,2,2,2,2,2,16,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0},
				{0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,2,2,2,2,2,2,2,16,2,2,2,16,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0},
				{0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,2,2,2,2,2,2,2,16,2,2,2,2,16,16,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0},
				{0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,16,16,2,2,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,14,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,8,8,8,8,8,8,4,14,8,8,8,4,4,4,14,4,4,4,4,4,4,4,4,8,8,8,8,2,16,16,2,2,2,2,2,16,16,16,16,2,2,2,2,16,16,2,16,8,8,8,8,4,4,4,4,4,4,4,4,4,4,18,18,4,8,8,8,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,8,8,18,4,4,4,4,4,4,18,4,4,18,18,8,4,4,4,4,4,4,4,4,4,8,8,8,8,8,2,16,2,16,16,16,2,2,2,16,16,16,16,16,2,2,2,16,16,16,16,16,8,8,8,8,8,8,4,8,8,4,4,4,18,18,18,18,4,4,4,4,18,8,8,8,8,8,8,8,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,8,8,8,8,18,18,17,4,17,4,17,4,18,17,4,18,18,18,8,4,19,4,8,4,20,4,8,8,8,8,8,2,2,16,16,16,2,2,2,2,16,16,16,16,16,16,16,2,2,2,16,16,16,16,16,8,8,8,8,8,8,8,8,8,18,18,18,18,18,18,17,4,17,4,18,18,18,8,8,8,8,8,8,8,8,8,8,4,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,16,16,2,2,2,2,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,16,16,2,2,2,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,16,16,2,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,16,16,16,16,16,0,0,16,16,16,16,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 4; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 1:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<TrueSandstoneTile>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 2:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<CursedTumorTile>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 3:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<CursedTumorTile>();
									tile.Slope = (SlopeType)3;
									tile.IsHalfBlock = false;
									break;
								case 4:
									if (confirmPlatforms == 0)
									{
										tile.HasTile = false;
										tile.IsHalfBlock = false;
										tile.Slope = 0;
									}
									break;
								case 5:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<CursedTumorTile>();
									tile.Slope = (SlopeType)4;
									tile.IsHalfBlock = false;
									break;
								case 6:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, TileID.Lamps, true, true, -1, 15);
									}
									break;
								case 7:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, ModContent.TileType<SarcophagusTile>(), true, true, -1, 0);
									}
									break;
								case 8:
									if (confirmPlatforms >= 1 && WorldGen.genRand.Next(9) > 1 && !tile.HasTile && Framing.GetTileSafely(k, l + 1).HasTile)
									{
										tile.HasTile = true;
										tile.TileType = TileID.GoldCoinPile;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
									}
									else
									{
										if (tile.TileType != TileID.GoldCoinPile)
											tile.HasTile = false;
									}
									break;
								case 9:
									if (confirmPlatforms == 0)
										tile.HasTile = false;
									WorldGen.PlaceTile(k, l, ModContent.TileType<AncientGoldPlatformTile>(), true, true, -1, 0);
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 10:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 11:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, 91, true, true, -1, 6);
									}
									break;
								case 12:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, 91, true, true, -1, 4);
									}
									break;
								case 13:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, ModContent.TileType<AncientGoldThroneTile>(), true, true, -1, 0);
									}
									break;
								case 14:
									if (confirmPlatforms >= 1)
									{
										if (!tile.HasTile)
										{
											WorldGen.PlaceTile(k, l, ModContent.TileType<AncientGoldCandelabraTile>(), true, true, -1, 0);
										}
									}
									else
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
									}
									break;
								case 15:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, ModContent.TileType<AncientGoldWorkbenchTile>(), true, true, -1, 0);
									}
									break;
								case 16:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<CursedHive>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 17:
									if (confirmPlatforms >= 1)
									{
										if (!tile.HasTile)
										{
											WorldGen.PlaceTile(k, l, TileID.FishingCrate, true, true, -1, 2);
											tile.Slope = 0;
											tile.IsHalfBlock = false;
										}
									}
									else
									{
										tile.HasTile = false;
									}
									break;
								case 18:
									if (confirmPlatforms == 0)
										tile.HasTile = false;
									else if (!tile.HasTile)
									{
										WorldGen.PlaceTile(k, l, TileID.MetalBars, true, true, -1, 6);
										tile.Slope = 0;
										tile.IsHalfBlock = false;
									}
									break;
								case 19:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, ModContent.TileType<AncientGoldTableTile>(), true, true, -1, 0);
									}
									break;
								case 20:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, ModContent.TileType<AncientGoldDresserTile>(), true, true, -1, 0);
									}
									break;
								case 21:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										WorldGen.PlaceTile(k, l, ModContent.TileType<AncientGoldGateTile>(), true, true, -1, 0);
										int left = k - 1;
										int top = l - 4;
										for (int x = left; x < left + 2; x++)
										{
											for (int y = top; y < top + 5; y++)
											{
												if (direction == -1)
													Main.tile[x, y].TileFrameX += 36;
												NetMessage.SendTileSquare(-1, x, y, 2);
											}
										}
									}
									break;
							}
						}
					}
				}
			}
		}
		public static bool TileDungeon(Tile tile)
		{
			return tile.TileType == TileID.BlueDungeonBrick || tile.TileType == TileID.GreenDungeonBrick || tile.TileType == TileID.PinkDungeonBrick || tile.WallType == 7 || tile.WallType == 8 || tile.WallType == 9 || tile.WallType == 94 || tile.WallType == 95 || tile.WallType == 96 || tile.WallType == 97 || tile.WallType == 98 || tile.WallType == 99;
		}
		public static void SetTilePyramid(Tile tile)
		{
			tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
			tile.Slope = 0;
			tile.IsHalfBlock = false;
			tile.LiquidType = 0;
			tile.LiquidType = 0;
			tile.HasTile = true;
		}
		public static void GenerateSOTSPyramid(Mod mod, bool generateAllSteps = true, int generateCertainStep = -1, int manualPlacementX = -1, int manualPlacementY = -1, int manualSeed = -1)
		{
			int dungeonSide = -1;
			if (Main.dungeonX > (int)(Main.maxTilesX / 2))
			{
				dungeonSide = 1;
			}
			// -1 = dungeon on left, 1 = dungeon on right
			if (manualSeed != -1)
				WorldGen._genRandSeed = manualSeed; //this should hopefull make the worldgen steps consistent with manual mode!
			int pyramidY = manualPlacementY;
			int pyramidX = manualPlacementX;
			int checks = 0;
			if(manualPlacementX == -1 || manualPlacementY == -1 || manualSeed == -1)
			{
				int xCheck = dungeonSide == 1 ? WorldGen.genRand.Next(500, Main.maxTilesX / 2) : WorldGen.genRand.Next(Main.maxTilesX / 2, Main.maxTilesX - 500);
				for (; xCheck != -1; xCheck = (dungeonSide == 1 ? WorldGen.genRand.Next(500, Main.maxTilesX / 2) : WorldGen.genRand.Next(Main.maxTilesX / 2, Main.maxTilesX - 500)))
				{
					for (int ydown = 0; ydown != -1; ydown++)
					{
						Tile tile = Framing.GetTileSafely(xCheck, ydown);
						if (tile.HasTile && (tile.TileType == TileID.Sand || tile.TileType == TileID.Ebonsand || tile.TileType == TileID.Crimsand || checks >= 1000))
						{
							if ((!WorldGen.UndergroundDesertLocation.Contains(new Point(xCheck, ydown + 60)) && !WorldGen.UndergroundDesertLocation.Contains(new Point(xCheck, ydown + 120))) || checks > 200)
							{
								pyramidY = ydown;
							}
							break;
						}
						else if (tile.HasTile)
						{
							break;
						}
					}
					if (pyramidY != -1)
					{
						pyramidX = xCheck;
						break;
					}
					checks++;
				}
			}
			else
			{
				pyramidY += 15;
            }
			pyramidY -= 15;
			int direction = WorldGen.genRand.Next(2) * 2 - 1;
			int finalDirection = direction;
			int nextAmount = WorldGen.genRand.Next(6, 16);
			int size = 300;
			int endingTileX = -1;
			int endingTileY = -1;
			int initialPath = 1;
			int worldSizeModifier = 0;
			if (Main.maxTilesX > 4000) //small worlds
			{
				worldSizeModifier = 4;
				size = 250;
			}
			if (Main.maxTilesX > 6000) //medium worlds
			{
				worldSizeModifier = 2;
				size = 275;
			}
			if (Main.maxTilesX > 8000) //big worlds
			{
				size = 300;
			}
			int thirdPoint = size / 5;
			int twoThirdPoint = (int)(size / 2.25f);
			int midPoint = size / 2;
			bool hasGeneratedDivertCooridor1 = false;
			bool hasGeneratedDivertCooridor2 = false;
			for (int pyramidLevel = 0; pyramidLevel < size; pyramidLevel++) //generate initial entrance into the pyramid
			{
				for (int h = -pyramidLevel; h <= pyramidLevel; h++)
				{
					Tile tile = Framing.GetTileSafely(pyramidX + h, pyramidY + pyramidLevel);
					if (!TileDungeon(tile)) //check for not dungeon!
					{
						SetTilePyramid(tile);
					}
				}
				for (int h = -pyramidLevel + 1; h <= pyramidLevel - 1; h++)
				{
					Tile tile = Framing.GetTileSafely(pyramidX + h, pyramidY + pyramidLevel);
					if (!TileDungeon(tile)) //check for not dungeon!
					{
						if (pyramidLevel <= 15)
							tile.WallType = (ushort)ModContent.WallType<PyramidWallWall>();
						else if (pyramidLevel == 16)
						{
							tile.WallType = (ushort)ModContent.WallType<PyramidBrickWallWall>();
						}
						else
						{
							tile.WallType = (ushort)ModContent.WallType<UnsafePyramidWallWall>();
						}
					}
				}
				if (pyramidLevel >= 10 && pyramidLevel <= 15)
				{
					if (direction == -1)
					{
						for (int g = -pyramidLevel; g <= pyramidLevel - 10; g++)
						{
							Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
							if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
								tile.HasTile = false;
						}
					}
					if (direction == 1)
					{
						for (int g = pyramidLevel; g >= -pyramidLevel + 10; g--)
						{
							Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
							if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
								tile.HasTile = false;
						}
					}
				}
				if (pyramidLevel >= 15 && initialPath == 1)
				{
					if (15 + nextAmount <= pyramidLevel)
					{
						initialPath = -1;
					}
					else
					{
						if (direction == -1)
						{
							for (int g = pyramidLevel - 16; g <= pyramidLevel - 10; g++)
							{
								Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
								if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
									tile.HasTile = false;
							}
							endingTileX = pyramidX + (pyramidLevel - 13);
						}
						if (direction == 1)
						{
							for (int g = -pyramidLevel + 16; g >= -pyramidLevel + 10; g--)
							{
								Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
								if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
									tile.HasTile = false;
							}
							endingTileX = pyramidX + (-pyramidLevel + 13);
						}
					}
					if (pyramidLevel == 16)
					{
						Tile tile = Framing.GetTileSafely(pyramidX + (pyramidLevel - 16) * -direction, pyramidY + pyramidLevel);
						SetTilePyramid(tile);
						tile.TileType = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
						tile = Framing.GetTileSafely(pyramidX + (pyramidLevel - 10) * -direction, pyramidY + pyramidLevel);
						SetTilePyramid(tile);
						tile.TileType = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
						WorldGen.PlaceTile(pyramidX + (pyramidLevel - 13) * -direction, pyramidY + pyramidLevel, ModContent.TileType<PyramidGateTile>(), true, true);
					}
					endingTileY = pyramidY + pyramidLevel;
				}
			}
			if (!generateAllSteps && generateCertainStep == 0)
				return;
			for (int totalAmount = 0; totalAmount < size; totalAmount += nextAmount) //generate downwards cooridor into the pyramid
			{
				direction *= -1;
				nextAmount = WorldGen.genRand.Next(6, 31);
				if (totalAmount > size - 230)
				{
					if (endingTileX > pyramidX && endingTileX < pyramidX + 85)
					{
						direction = 1;
						finalDirection = -1;
					}
					if (endingTileX < pyramidX && endingTileX > pyramidX - 85)
					{
						direction = -1;
						finalDirection = 1;
					}
				}
				for (int g = nextAmount; g > 0; g--)
				{
					endingTileX += direction;
					for (int h = 3; h >= -3; h--)
					{
						Tile tile = Framing.GetTileSafely(endingTileX + h, endingTileY);
						if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
							tile.HasTile = false;
					}
					endingTileY++;
					if (endingTileY - pyramidY >= size)
					{
						break;
					}
				}
				if (!hasGeneratedDivertCooridor1 && totalAmount >= thirdPoint)
				{
					for (int cooridorX = -totalAmount / 2; cooridorX < totalAmount; cooridorX++)
					{
						int findTileX = (cooridorX * finalDirection) + endingTileX;
						for (int y1 = 2; y1 >= -2; y1--) //top cooridor
						{
							bool capable = true;
							Tile selectTile;
							for (int check = -2; check <= 2; check++)
							{
								selectTile = Framing.GetTileSafely(findTileX + check, endingTileY + y1);
								if (selectTile.TileType != (ushort)ModContent.TileType<PyramidSlabTile>())
								{
									capable = false;
									break;
								}
							}
							selectTile = Framing.GetTileSafely(findTileX, endingTileY + y1);
							if (capable)
								selectTile.HasTile = false;
						}
					}
					int spawnX = endingTileX + totalAmount * finalDirection - 4 * finalDirection;
					GeneratePyramidPath(mod, spawnX, endingTileY, spawnX + WorldGen.genRand.Next(40, 61) * finalDirection, pyramidY + midPoint - 16, finalDirection, 20, true);
					endingTileX += (int)(totalAmount * 0.66f) * finalDirection;
					hasGeneratedDivertCooridor1 = true;
					finalDirection *= -1;
				}
				else if (!hasGeneratedDivertCooridor2 && totalAmount >= twoThirdPoint)
				{
					int length = totalAmount + 20;
					for (int cooridorX = -length / 2; cooridorX < length; cooridorX++)
					{
						int findTileX = (cooridorX * finalDirection) + endingTileX;
						for (int y1 = 2; y1 >= -2; y1--) //top cooridor
						{
							bool capable = true;
							Tile selectTile;
							for (int check = -2; check <= 2; check++)
							{
								selectTile = Framing.GetTileSafely(findTileX + check, endingTileY + y1);
								if (selectTile.TileType != (ushort)ModContent.TileType<PyramidSlabTile>())
								{
									capable = false;
									break;
								}
							}
							selectTile = Framing.GetTileSafely(findTileX, endingTileY + y1);
							if (capable)
								selectTile.HasTile = false;
						}
					}
					int spawnX = endingTileX + length * finalDirection - 5 * finalDirection;
					GeneratePyramidPath(mod, spawnX, endingTileY, spawnX + WorldGen.genRand.Next(30, 51) * finalDirection, pyramidY + midPoint, -finalDirection, 24, true);
					endingTileX += (int)(length * 0.75f) * finalDirection;
					hasGeneratedDivertCooridor2 = true;
					finalDirection *= -1;
				}
			}
			if (!generateAllSteps && generateCertainStep == 1)
				return;
			GeneratePyramidPath(mod, endingTileX, pyramidY + size, pyramidX, pyramidY + size + 16, -finalDirection, 45, true);
			if (!generateAllSteps && generateCertainStep == 2)
				return;

			//creates cooridors
			int overgrownX = -1;
			int overgrownY = -1;
			int counterL = 0;
			int counterR = 0;
			int counterSpike = 0;
			bool continueCooridor = true;
			for (int fx = -size; fx < size; fx++)
			{
				int findTileX = (fx * -finalDirection) + pyramidX;
				for (int y1 = 2; y1 >= -2; y1--) //top cooridor
				{
					int higherUpY = pyramidY + 30;
					bool capable = true;
					Tile selectTile;
					for (int check = -2; check <= 2; check++)
					{
						selectTile = Framing.GetTileSafely(findTileX + check, higherUpY + y1);
						if (selectTile.TileType != (ushort)ModContent.TileType<PyramidSlabTile>())
						{
							capable = false;
							break;
						}
					}
					selectTile = Framing.GetTileSafely(findTileX, higherUpY + y1);
					if (capable)
						selectTile.HasTile = false;
				}
				int counterInvalid = 0;
				for (int y1 = 2; y1 >= -2; y1--) //zeppelin room and burial room cooridor
				{
					int higherUpY = pyramidY + (size - 40);
					if (!continueCooridor)
					{
						if (overgrownX == -1 && overgrownY == -1)
						{
							overgrownX = findTileX - (36 * finalDirection);
							overgrownY = higherUpY;
						}
						break;
					}
					bool capable = true;
					Tile selectTile;
					for (int check = -2; check <= 2; check++)
					{
						selectTile = Framing.GetTileSafely(findTileX + check, higherUpY + y1);
						if (selectTile.TileType != (ushort)ModContent.TileType<PyramidSlabTile>())
						{
							capable = false;
							break;
						}
					}
					selectTile = Framing.GetTileSafely(findTileX, higherUpY + y1);
					if (capable)
						selectTile.HasTile = false;
					int failureC = 0;
					for (int check = -1; check <= 1; check++)
					{
						selectTile = Framing.GetTileSafely(findTileX + check, higherUpY + y1);
						if (!selectTile.HasTile && selectTile.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>()) //end the cooridor upon reaching the stairwell
						{
							failureC++;
						}
					}
					if (failureC >= 3)
						counterInvalid++;
					if (counterInvalid >= 5)
						continueCooridor = false;
				}
				for (int y1 = 2; y1 >= -2; y1--) //sandslabe cooridor for zepline room
				{
					int higherUpY = pyramidY + (size - 12);
					Tile selectTile = Framing.GetTileSafely(findTileX, higherUpY + y1);
					if (selectTile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && selectTile.HasTile)
					{
						selectTile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274;
					}
				}
				for (int findTileY = pyramidY + (size - 55); findTileY > pyramidY + 20; findTileY--) //generating spikes
				{
					int max = Math.Abs((int)((findTileY - pyramidY) * 0.8f));
					int min = Math.Abs((int)((findTileY - pyramidY) * 0.5f));
					Tile tile = Framing.GetTileSafely(findTileX, findTileY);
					Tile tileLeft = Framing.GetTileSafely(findTileX - 1, findTileY);
					Tile tileRight = Framing.GetTileSafely(findTileX + 1, findTileY);
					if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
					{
						if (!(findTileY > pyramidY + (size - 70) && finalDirection == 1) && tileLeft.HasTile && tile.HasTile && !tileRight.HasTile && tileRight.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>())
						{
							//generate cooridor to the left
							int randDistance = WorldGen.genRand.Next(min, max);
							counterL++;
							int height = 2;
							if (WorldGen.genRand.NextBool(3) && counterL >= 40)
							{
								int coorXPos = findTileX + 2;
								for (int dis = randDistance; dis > 0; dis--)
								{
									for (int y1 = height; y1 >= -height; y1--)
									{
										Tile selectTile = Framing.GetTileSafely(coorXPos, findTileY + y1);
										Tile selectTileLeft = Framing.GetTileSafely(coorXPos - 1, findTileY + y1);
										Tile selectTileLeft2 = Framing.GetTileSafely(coorXPos - 2, findTileY + y1);
										Tile selectTileLeft3 = Framing.GetTileSafely(coorXPos - 3, findTileY + y1);
										if (selectTile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
										{
											bool tile3isCursed = selectTileLeft3.TileType == ModContent.TileType<CursedTumorTile>() || selectTileLeft3.TileType == ModContent.TileType<CursedHive>() || selectTileLeft2.TileType == ModContent.TileType<CursedHive>() || selectTileLeft.TileType == ModContent.TileType<CursedHive>();
											if (tile3isCursed || (selectTileLeft.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && selectTileLeft2.TileType == (ushort)ModContent.TileType<PyramidSlabTile>()))
											{
												selectTile.HasTile = false;
											}
										}
									}
									coorXPos--;
									counterL = 0;
								}
							}
						}
						if (!(findTileY > pyramidY + (size - 70) && finalDirection == -1) && tileRight.HasTile && tile.HasTile && !tileLeft.HasTile && tileLeft.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>())
						{
							//generate cooridor to the right
							int randDistance = WorldGen.genRand.Next(min, max);
							counterR++;
							int height = 2;
							if (WorldGen.genRand.NextBool(3) && counterR >= 40)
							{
								int coorXPos = findTileX - 2;
								for (int dis = randDistance; dis > 0; dis--)
								{
									for (int y1 = height; y1 >= -height; y1--)
									{
										Tile selectTile = Framing.GetTileSafely(coorXPos, findTileY + y1);
										Tile selectTileRight = Framing.GetTileSafely(coorXPos + 1, findTileY + y1);
										Tile selectTileRight2 = Framing.GetTileSafely(coorXPos + 2, findTileY + y1);
										Tile selectTileRight3 = Framing.GetTileSafely(coorXPos + 3, findTileY + y1);
										if (selectTile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
										{
											bool tile3isCursed = selectTileRight3.TileType == ModContent.TileType<CursedTumorTile>() || selectTileRight3.TileType == ModContent.TileType<CursedHive>() || selectTileRight2.TileType == ModContent.TileType<CursedHive>() || selectTileRight.TileType == ModContent.TileType<CursedHive>();
											if (tile3isCursed || (selectTileRight.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && selectTileRight2.TileType == (ushort)ModContent.TileType<PyramidSlabTile>()))
											{
												selectTile.HasTile = false;
											}
										}
									}
									coorXPos++;
									counterR = 0;
								}
							}
						}
						Tile tileUp = Framing.GetTileSafely(findTileX, findTileY - 1);
						Tile tileDown = Framing.GetTileSafely(findTileX, findTileY + 1);
						if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && tile.HasTile && tileLeft.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && tileLeft.HasTile && tileRight.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && tileRight.HasTile && (!tileUp.HasTile || !tileDown.HasTile))
						{
							counterSpike++;
							if (counterSpike >= 44)
							{
								counterSpike = 0;
								int spikeSize = WorldGen.genRand.Next(4, 17);
								int secondSize = WorldGen.genRand.Next(4, 17);
								if (spikeSize > secondSize)
									spikeSize = secondSize;
								for (int sizeSpike = 0; sizeSpike < spikeSize; sizeSpike++)
								{
									Tile tileSpikeR = Framing.GetTileSafely(findTileX + sizeSpike, findTileY);
									Tile tileSpikeRR = Framing.GetTileSafely(findTileX + sizeSpike + 1, findTileY);
									Tile tileSpikeRU = Framing.GetTileSafely(findTileX + sizeSpike, findTileY - 1);
									Tile tileSpikeRD = Framing.GetTileSafely(findTileX + sizeSpike, findTileY + 1);
									Tile tileSpikeL = Framing.GetTileSafely(findTileX - sizeSpike, findTileY);
									Tile tileSpikeLL = Framing.GetTileSafely(findTileX - sizeSpike - 1, findTileY);
									Tile tileSpikeLU = Framing.GetTileSafely(findTileX - sizeSpike, findTileY - 1);
									Tile tileSpikeLD = Framing.GetTileSafely(findTileX - sizeSpike, findTileY + 1);
									if (tileSpikeR.HasTile && tileSpikeR.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && tileSpikeL.HasTile && tileSpikeL.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
									{
										bool ending = sizeSpike == spikeSize - 1 || !tileSpikeRR.HasTile || !tileSpikeLL.HasTile;
										ushort type = ending ? (ushort)ModContent.TileType<RoyalGoldBrickTile>() : (ushort)ModContent.TileType<AncientGoldSpikeTile>();
										if (tileSpikeLU.HasTile == false && tileSpikeLD.HasTile == true)
										{
											tileSpikeL.TileType = type;
											tileSpikeLD.TileType = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
										}
										if (tileSpikeRU.HasTile == false && tileSpikeRD.HasTile == true)
										{
											tileSpikeR.TileType = type;
											tileSpikeRD.TileType = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
										}
										if (tileSpikeLU.HasTile == true && tileSpikeLD.HasTile == false)
										{
											tileSpikeL.TileType = type;
											tileSpikeLU.TileType = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
										}
										if (tileSpikeRU.HasTile == true && tileSpikeRD.HasTile == false)
										{
											tileSpikeR.TileType = type;
											tileSpikeRU.TileType = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
										}
									}
									else
									{
										break;
									}
								}
							}
						}
					}
				}
			}
			if (!generateAllSteps && generateCertainStep == 3)
				return;
			int bossPosX = pyramidX + ((size - 115) * finalDirection);
			if (finalDirection == 1)
				bossPosX += 1;
			int bossPosY = pyramidY + (size - 40);
			GenerateBossRoom(bossPosX, bossPosY, finalDirection);
			if (!generateAllSteps && generateCertainStep == 4)
				return;

			bool buildSword = false;
			bool buildPick = false;
			while (!buildPick)
			{
				int findTileY = WorldGen.genRand.Next(pyramidY + 40, pyramidY + (size - 70));
				int width = findTileY - pyramidY;
				int findTileX = pyramidX + WorldGen.genRand.Next(-width, width + 1);
				int structureWidth = 19;
				int structureHeight = 14;
				int structureRect = structureHeight * structureWidth;
				int count = 0;
				for (int i = 0; i < structureWidth; i++)
				{
					for (int j = 0; j < structureHeight; j++)
					{
						Tile tile = Framing.GetTileSafely(findTileX + i, findTileY + j);
						if (tile.HasTile && tile.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() && tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
						{
							count++;
						}
					}
				}
				if (count == structureRect)
				{
					buildPick = true;
					GenerateShrineRoom(findTileX, findTileY, mod, 0);
				}
			}
			while (!buildSword)
			{
				int findTileY = WorldGen.genRand.Next(pyramidY + 40, pyramidY + (size - 70));
				int width = findTileY - pyramidY;
				int findTileX = pyramidX + WorldGen.genRand.Next(-width, width + 1);
				int structureWidth = 19;
				int structureHeight = 14;
				int structureRect = structureHeight * structureWidth;
				int count = 0;
				for (int i = 0; i < structureWidth; i++)
				{
					for (int j = 0; j < structureHeight; j++)
					{
						Tile tile = Framing.GetTileSafely(findTileX + i, findTileY + j);
						if (tile.HasTile && tile.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() && tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
						{
							count++;
						}
					}
				}
				if (count == structureRect)
				{
					buildSword = true;
					GenerateShrineRoom(findTileX, findTileY, mod, 1);
				}
			}
			if (!generateAllSteps && generateCertainStep == 5)
				return;
			float counterRoom = 0;
			for (int findTileY = pyramidY + (size - 70); findTileY > pyramidY + 25; findTileY--)
			{
				counterRoom += 6f;
				int width = findTileY - pyramidY;
				if (counterRoom >= 24)
				{
					while (counterRoom > 0)
					{
						int findTileX = pyramidX + WorldGen.genRand.Next(-width, width + 1);
						Tile tile = Framing.GetTileSafely(findTileX, findTileY);
						if (tile.HasTile && tile.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() && tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
						{
							counterRoom--;
							bool canBeLeft = false;
							bool canBeRight = false;
							bool canBeUp = false;
							bool canBeDown = false;
							int tilesLeft = 0;
							int tilesRight = 0;
							int tilesUp = 0;
							int tilesDown = 0;
							int squareCount = 0;
							for (int checkLeft = 0; checkLeft < 80; checkLeft++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX - checkLeft, findTileY);
								if (!tileCheck.HasTile && tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>())
								{
									tilesLeft = checkLeft;
									break;
								}
								if (tileCheck.HasTile && (tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() || tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>()) && tileCheck.TileType == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesLeft = -1;
									break;
								}
							}
							for (int checkRight = 0; checkRight < 80; checkRight++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX + checkRight, findTileY);
								if (!tileCheck.HasTile && tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>())
								{
									tilesRight = checkRight;
									break;
								}
								if (tileCheck.HasTile && (tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() || tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>()) && tileCheck.TileType == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesRight = -1;
									break;
								}
							}
							for (int checkUp = 0; checkUp < 40; checkUp++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX, findTileY - checkUp);
								if (!tileCheck.HasTile && tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>())
								{
									tilesUp = checkUp;
									break;
								}
								if (tileCheck.HasTile && (tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() || tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>()) && tileCheck.TileType == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesUp = -1;
									break;
								}
							}
							for (int checkDown = 0; checkDown < 80; checkDown++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX, findTileY + checkDown);
								if (!tileCheck.HasTile && tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>())
								{
									tilesDown = checkDown;
									break;
								}
								if (tileCheck.HasTile && (tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() || tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>()) && tileCheck.TileType == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesDown = -1;
									break;
								}
							}
							for (int checkSquareX = -12; checkSquareX <= 12; checkSquareX++)
							{
								for (int checkSquareY = -12; checkSquareY <= 12; checkSquareY++)
								{
									Tile tileCheck = Framing.GetTileSafely(findTileX + checkSquareX, findTileY + checkSquareY);
									if (tileCheck.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && tileCheck.HasTile && tileCheck.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>())
									{
										squareCount++;
									}
								}
							}
							if (squareCount >= 625 && tilesDown >= 0 && tilesUp >= 0 && tilesLeft >= 0 && tilesRight >= 0)
							{
								if (tilesRight > tilesDown && tilesRight > tilesUp && tilesRight > tilesLeft)
								{
									canBeRight = true;
								}
								if (tilesLeft > tilesDown && tilesLeft > tilesUp && tilesLeft > tilesRight)
								{
									canBeLeft = true;
								}
								if (tilesDown > tilesUp && tilesDown > tilesLeft && tilesDown > tilesRight)
								{
									canBeDown = true;
								}
								if ((int)(tilesUp * 1.2f) > tilesRight && (int)(tilesUp * 1.2f) > tilesDown && (int)(tilesUp * 1.2f) > tilesLeft) //check this last because of the priority modifications
								{
									canBeUp = true;
								}
							}
							if (canBeRight)
							{
								GeneratePyramidRoom(findTileX, findTileY, 1, mod);
								break;
							}
							if (canBeLeft)
							{
								GeneratePyramidRoom(findTileX, findTileY, 0, mod);
								break;
							}
							if (canBeDown)
							{
								GeneratePyramidRoom(findTileX, findTileY, 3, mod);
								break;
							}
							if (canBeUp)
							{
								GeneratePyramidRoom(findTileX, findTileY, 2, mod);
								break;
							}
						}
					}
				}
			}
			if (!generateAllSteps && generateCertainStep == 6)
				return;
			GenerateZepline(pyramidX, pyramidY + (size - 40), mod);
			if (!generateAllSteps && generateCertainStep == 7)
				return;

			//rebuild outside of pyramid
			for (int pyramidLevel = 0; pyramidLevel < size; pyramidLevel++)
			{
				for (int h = -pyramidLevel; h <= pyramidLevel; h++)
				{
					Tile tile = Framing.GetTileSafely(pyramidX + h, pyramidY + pyramidLevel);
					if (pyramidLevel >= 20 && h < -pyramidLevel + 2 && h > pyramidLevel - 2)
						if (!TileDungeon(tile)) //check for not dungeon!
						{
							SetTilePyramid(tile);
						}
				}
			}
			if (!generateAllSteps && generateCertainStep == 8)
				return;
			if (overgrownX != -1 && overgrownY != -1)
				SOTSWorldgenHelper.GenerateAcediaRoom(overgrownX, overgrownY, mod, finalDirection);
			if (!generateAllSteps && generateCertainStep == 9)
				return;
			int sizeNumber = 0;
			for (int findTileY = pyramidY + (size - 30); findTileY > pyramidY + 30; findTileY--)
			{
				int width = findTileY - pyramidY;
				for (int t = 0; t < 6; t++)
				{
					int findTileX = pyramidX + WorldGen.genRand.Next(-width, width + 1);
					Tile tile = Framing.GetTileSafely(findTileX, findTileY);
					for (int built = 0; built < 2; built++)
					{
						if (tile.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() && (!tile.HasTile || WorldGen.genRand.NextBool((int)(size / 2.66f))))
						{
							Tile tile2 = Framing.GetTileSafely(findTileX, findTileY - 3);
							Tile tile3 = Framing.GetTileSafely(findTileX, findTileY + 3);
							bool tile2Valid = tile2.HasTile && tile2.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && tile2.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>();
							bool tile3Valid = tile3.HasTile && tile3.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() && tile3.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>();
							if (tile2Valid && tile3Valid)
							{
								if (!WorldGen.genRand.NextBool(4))
								{
									GenerateInfection(new Vector2(findTileX * 16, findTileY * 16), mod);
								}
								else
								{
									float thickness = WorldGen.genRand.NextFloat(0.65f, 1.25f);
									int width2 = WorldGen.genRand.Next(7, 19 - worldSizeModifier);
									int height = WorldGen.genRand.Next(5, 13 - worldSizeModifier / 2);
									GeneratePyramidOval(mod, findTileX, findTileY, width2, height, thickness, 3, true);
									break;
								}
								findTileX += WorldGen.genRand.Next(-20, 21);
							}
							else break;
						}
						else break;
					}
				}
				if (findTileY > pyramidY + 30 && findTileY < pyramidY + size - 10)
				{
					int spawnInterval = size / 4;
					if ((findTileY - pyramidY) % spawnInterval == 0)
					{
						for (int i = 0; i < 1 + sizeNumber * 2; i++)
						{
							int randOffY = WorldGen.genRand.Next(-(sizeNumber + i) * 8 - 5, (sizeNumber + i) * 8 + 10);
							int randOff = WorldGen.genRand.Next(-width + 20, width - 19);
							int currentXSize = pyramidX + randOff;
							DoAltBlocksGeneration(currentXSize, findTileY + randOffY + 30, 12 - worldSizeModifier + 10 * sizeNumber - i * 2);
						}
						sizeNumber++;
					}
				}
			}
			if (!generateAllSteps && generateCertainStep == 10)
				return;
			int extraSize = size + 50;
			for (int findTileY = pyramidY + (size - 30); findTileY > pyramidY + 30; findTileY--)
			{
				for (int findTileX = pyramidX + extraSize; findTileX > pyramidX - extraSize; findTileX--)
				{
					Tile tile = Framing.GetTileSafely(findTileX, findTileY);
					Tile tileU = Framing.GetTileSafely(findTileX, findTileY - 1);
					Tile tileLU = Framing.GetTileSafely(findTileX - 1, findTileY - 1);
					Tile tileU2 = Framing.GetTileSafely(findTileX, findTileY - 2);
					Tile tileLU2 = Framing.GetTileSafely(findTileX - 1, findTileY - 2);
					Tile tileU3 = Framing.GetTileSafely(findTileX, findTileY - 3);
					Tile tileLU3 = Framing.GetTileSafely(findTileX - 1, findTileY - 3);
					bool validType = tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() || tile.TileType == (ushort)ModContent.TileType<PyramidBrickTile>() || tile.TileType == (ushort)ModContent.TileType<RuinedPyramidBrickTile>() || tile.TileType == (ushort)ModContent.TileType<PyramidRubbleTile>();
					if (validType && !tileLU.HasTile && !tileLU2.HasTile && !tileU.HasTile && !tileU2.HasTile)
					{
						if (WorldGen.genRand.NextBool(4))
						{
							WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidPots>(), true, true, -1, WorldGen.genRand.Next(9)); //pots
						}
						else if (WorldGen.genRand.Next(size / 2) == 0)
						{
							if (WorldGen.genRand.NextBool(2))
							{
								WorldGen.PlaceTile(findTileX, findTileY - 1, (ushort)ModContent.TileType<CrystalStatue>()); //life crystal
							}
							else
							{
								WorldGen.PlaceTile(findTileX, findTileY - 1, (ushort)ModContent.TileType<ManaStatue>()); //mana crystal
							}
						}
						else if (WorldGen.genRand.NextBool(size / 3))
						{
							WorldGen.PlaceTile(findTileX, findTileY - 1, (ushort)ModContent.TileType<PyramidChestTile>()); //Chests
						}
						else if (WorldGen.genRand.NextBool((int)(size / 3.5f)))
						{
							GenerateCrate(findTileX, findTileY - 1, mod);
						}
						else if (!tileU3.HasTile && !tileLU3.HasTile && WorldGen.genRand.NextBool(size / 2))
						{
							WorldGen.PlaceTile(findTileX, findTileY - 1, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
						}
					}
					if (tile.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() && WorldGen.genRand.NextBool(500) && tile.TileType != ModContent.TileType<CursedTumorTile>() && tile.HasTile)
					{
						int radius7 = 6;
						for (int x = -radius7; x <= radius7; x++)
						{
							for (int y = -radius7; y <= radius7; y++)
							{
								int xPosition6 = findTileX + x;
								int yPosition6 = findTileY + y;
								if (Math.Sqrt(x * x + y * y) <= radius7 + 0.5)
								{
									float distFromCenter = (float)Math.Sqrt(x * x + y * y);
									int distRand = (int)distFromCenter;
									Tile tileRad = Framing.GetTileSafely(xPosition6, yPosition6);
									if (!tileRad.HasTile && tileRad.WallType != ModContent.WallType<UnsafeCursedTumorWallWall>() && WorldGen.genRand.Next(100) > 4 + distRand * 5)
									{
										tileRad.TileType = 51; //cobweb
										tileRad.HasTile = true;
									}
								}
							}
						}
					}
				}
			}
			if (!generateAllSteps && generateCertainStep == 11) //11: add cobwebs and loot
				return;
			//int malditeNum = 0;
			for (int findTileY = pyramidY - 50; findTileY < pyramidY + extraSize; findTileY++)
			{
				int width = findTileY - pyramidY;
				for (int findTileX = pyramidX + extraSize; findTileX > pyramidX - extraSize; findTileX--)
				{
					Tile tile = Framing.GetTileSafely(findTileX, findTileY);
					if (tile.TileType == ModContent.TileType<CursedTumorTile>() && tile.HasTile)
					{
						tile.WallType = (ushort)ModContent.WallType<UnsafeCursedTumorWallWall>();
					}
					if (width > 16 && WorldGen.genRand.NextBool((int)(2300 - width * 5f)) && tile.HasTile && (tile.TileType == ModContent.TileType<RuinedPyramidBrickTile>() || tile.TileType == ModContent.TileType<PyramidSlabTile>()))
					{
						int extraWidth = width / 50;
						DoAltBlocksGeneration(findTileX, findTileY, 5 + extraWidth + WorldGen.genRand.Next(10 - worldSizeModifier), true);
					}
					if (!WorldGen.genRand.NextBool(5))
					{
						if (tile.HasTile && (tile.TileType == ModContent.TileType<CursedTumorTile>() || tile.WallType == (ushort)ModContent.WallType<UnsafeCursedTumorWallWall>()))
						{
							int randType = WorldGen.genRand.Next(6);
							if (randType == 0)
							{
								int left = findTileX;
								int top = findTileY - 1;
								Tile tile2 = Framing.GetTileSafely(left, top);
								if (!tile2.HasTile)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile1x1Curse>(), false, false, -1, 0);
							}
							else if (randType == 1)
							{
								int left = findTileX;
								int top = findTileY - 1;
								bool capable = true;
								for (int i = left; i < left + 2; i++)
								{
									for (int j = top; j < top + 2; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile2x1Curse>(), false, false, -1, WorldGen.genRand.Next(2));
							}
							else if (randType == 2)
							{
								int left = findTileX;
								int top = findTileY - 1;
								bool capable = true;
								for (int i = left; i < left + 3; i++)
								{
									for (int j = top; j < top + 2; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile3x1Curse>(), false, false, -1, 0);
							}
							else if (randType == 3 || randType == 5)
							{
								int left = findTileX;
								int top = findTileY - 2;
								bool capable = true;
								for (int i = left; i < left + 3; i++)
								{
									for (int j = top; j < top + 3; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile3x2Curse>(), false, false, -1, WorldGen.genRand.Next(3));
							}
							else if (randType == 4)
							{
								int left = findTileX - 1;
								int top = findTileY - 2;
								bool capable = true;
								for (int i = left; i < left + 4; i++)
								{
									for (int j = top; j < top + 3; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<CursedGrowthTile>());
							}
						}
						/*if (tile.HasTile && (tile.TileType == ModContent.TileType<MalditeTile>() || tile.WallType == (ushort)ModContent.WallType<UnsafeMalditeWallWall>()))
						{
							int randType = WorldGen.genRand.Next(3);
							if (randType == 0)
							{
								int left = findTileX;
								int top = findTileY - 1;
								Tile tile2 = Framing.GetTileSafely(left, top);
								if (!tile2.HasTile)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile1x1Curse>(), false, false, -1, 1 + WorldGen.genRand.Next(2));
							}
							else if (randType == 1)
							{
								int left = findTileX;
								int top = findTileY - 1;
								bool capable = true;
								for (int i = left; i < left + 2; i++)
								{
									for (int j = top; j < top + 2; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile2x1Curse>(), false, false, -1, 2);
							}
							else if (randType == 2)
							{
								int left = findTileX;
								int top = findTileY - 2;
								bool capable = true;
								for (int i = left; i < left + 3; i++)
								{
									for (int j = top; j < top + 3; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile3x2Curse>(), false, false, -1, 0);
							}
						}*/
					}
					if (WorldGen.genRand.NextBool(3))
						if (tile.WallType != 0 && tile.HasTile && (tile.TileType == ModContent.TileType<PyramidBrickTile>() || tile.TileType == ModContent.TileType<PyramidSlabTile>() || tile.TileType == ModContent.TileType<RuinedPyramidBrickTile>() || tile.TileType == ModContent.TileType<PyramidRubbleTile>() || tile.WallType == (ushort)ModContent.WallType<PyramidWallWall>()))
						{
							int randType = WorldGen.genRand.Next(3);
							if (randType == 0)
							{
								int left = findTileX;
								int top = findTileY - 1;
								Tile tile2 = Framing.GetTileSafely(left, top);
								if (!tile2.HasTile)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile1x1>(), false, false, -1, WorldGen.genRand.Next(2));
							}
							else if (randType == 1)
							{
								int left = findTileX;
								int top = findTileY - 1;
								bool capable = true;
								for (int i = left; i < left + 2; i++)
								{
									for (int j = top; j < top + 2; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile2x1>(), false, false, -1, WorldGen.genRand.Next(3));
							}
							else if (randType == 2)
							{
								int left = findTileX;
								int top = findTileY - 2;
								bool capable = true;
								for (int i = left; i < left + 2; i++)
								{
									for (int j = top; j < top + 3; j++)
									{
										Tile tile2 = Framing.GetTileSafely(i, j);
										if ((tile2.HasTile && j != findTileY) || (j == findTileY && !tile2.HasTile))
										{
											capable = false;
											break;
										}
									}
								}
								if (capable)
									WorldGen.PlaceTile(findTileX, findTileY - 1, ModContent.TileType<PyramidAmbientTile2x2>(), false, false, -1, 0);
							}
						}

				}
			}
			if (!generateAllSteps && generateCertainStep == 12) //12: add ambient tiles and ruined block clusters
				return;
		}
		public static void GenerateZepline(int spawnX, int spawnY, Mod mod)
		{
			int[,] _zepline = {
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,3,2,3,3,3,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2},
					{0,0,0,0,0,0,0,3,3,2,3,2,3,3,3,3,3,2,2,2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2},
					{0,0,0,0,0,0,0,0,3,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,9,9,5,0,0,0,5,9,9,2,2,2,3,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,2,3,3,3,3,3,3,3,2,3,2,3,2,3,2,4,4,4,0,0,0,4,4,4,2,2,3,3,3,2,2,2},
					{0,0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,3,2,3,0,3,0,3,2,2,2,3,0,0,0,3,2,2,2,3,3,0,3,3,2,2},
					{0,0,0,0,0,0,0,0,0,0,3,0,5,9,5,0,3,2,0,0,0,0,0,0,2,2,3,0,0,0,3,2,2,3,3,0,0,0,3,3,2},
					{9,6,0,0,0,0,0,0,0,0,3,0,4,4,4,0,3,0,0,0,0,0,0,0,0,2,2,0,0,0,2,2,3,3,0,0,0,0,0,3,3},
					{3,3,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{2,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,9,9,9,9,9,9,9,3},
					{9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,9,9,9,9,9,3,3},
					{3,3,3,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,9,9,9,3,3,2},
					{7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,9,3,3,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,9,3,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,9,9,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,9,6,6,0,1,3,3,3,3,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,3,8,0,0,1,3,3,3,2,2,9,2,2,2,2},
					{9,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,9,2,2,2,2},
					{3,3,3,3,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,9,9,9,9,9,9,9,9,9,6,2,2,2,2,2,9,2,2,2,2},
					{2,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,6,9,9,9,9,9,6,3,3,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,9,3,3,3,3,3,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,6,6,9,9,9,9,9,9,9,9,9,9,9,9,2,2,2,3,3,9,3,3,2,2,2,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,3,3,9,9,9,9,9,9,9,9,9,9,9,9,2,2,2,2,2,9,2,2,2,2,2,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,3,3,9,9,9,9,9,9,9,9,9,9,9,3,3,2,2,2,2,9,9,9,3,3,3,3,3,3,9,9,9,2,2,2,2},
					{9,9,9,9,9,9,9,3,9,9,9,9,9,9,9,9,9,9,9,3,3,2,2,2,2,3,9,9,9,9,9,9,9,9,9,9,9,2,2,2,2},
					{9,9,9,9,9,9,9,3,3,9,9,9,9,9,9,9,9,9,3,3,3,2,2,2,2,3,3,9,9,9,9,9,9,9,9,9,9,2,2,2,2},
					{9,9,9,9,9,9,9,3,3,3,9,9,9,9,9,9,9,3,3,3,2,2,3,3,3,3,3,3,3,9,9,9,9,9,9,9,3,2,2,2,2},
					{9,9,9,9,9,9,9,2,3,3,3,3,9,9,9,3,3,3,3,2,2,2,2,3,3,3,3,3,9,9,9,9,9,9,9,3,3,2,2,2,2},
					{9,9,9,9,9,9,9,2,2,3,3,3,3,9,3,3,3,3,2,2,2,2,2,2,3,3,3,9,9,9,9,9,9,9,3,3,3,2,2,2,2},
					{9,9,9,9,9,9,2,2,2,2,2,2,2,9,2,2,2,2,2,2,2,2,2,2,2,3,9,9,9,9,9,9,9,3,3,3,3,2,2,2,2},
					{9,9,9,9,9,2,2,2,2,2,2,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,2,2,2,2},
					{9,9,2,2,2,2,2,2,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,2,2,2,2},
					{9,2,2,2,2,2,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{9,9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				};
			int[,] _zeplineWalls = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{2,2,2,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{2,2,2,2,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				};

			int pyramidPosX = spawnX;
			int pyramidPosY = spawnY;
			pyramidPosY -= (int)(.5f * _zepline.GetLength(0)) - 10;

			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
			{
				for (int y = 0; y < _zepline.GetLength(0); y++)
				{
					for (int x = 0; x < _zepline.GetLength(1); x++)
					{
						int k = pyramidPosX + x;
						int l = pyramidPosY + y;
						int k2 = pyramidPosX - x;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							Tile tile2 = Framing.GetTileSafely(k2, l);
							switch (_zepline[y, x])
							{
								case 0:
									if (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
										tile.HasTile = false;

									if (tile2.TileType == (ushort)ModContent.TileType<PyramidSlabTile>())
										tile2.HasTile = false;
									break;
								case 1:
									tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274;
									tile.HasTile = true;
									tile.Slope = (SlopeType)4;
									tile2.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274;
									tile2.HasTile = true;
									tile2.Slope = (SlopeType)3;
									break;
								case 2:
									tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
									tile.HasTile = true;
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									tile2.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
									tile2.HasTile = true;
									tile2.Slope = 0;
									tile2.IsHalfBlock = false;
									break;
								case 3:
									tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274; //sandstone slab
									tile.HasTile = true;
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									tile2.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274;
									tile2.HasTile = true;
									tile2.Slope = 0;
									tile2.IsHalfBlock = false;
									break;
								case 4:
									tile.TileType = 326; //waterfall
									tile.HasTile = true;
									tile.Slope = 0;
									tile.IsHalfBlock = false;

									tile2.TileType = 326; //waterfall
									tile2.HasTile = true;
									tile2.Slope = 0;
									tile2.IsHalfBlock = false;
									break;
								case 5:
									tile.TileType = 326; //waterfall
									tile.HasTile = true;
									tile.IsHalfBlock = true;
									tile2.TileType = 326; //waterfall
									tile2.HasTile = true;
									tile2.IsHalfBlock = true;
									break;
								case 6:
									tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274;
									tile.HasTile = true;
									tile.IsHalfBlock = true;
									tile2.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274;
									tile2.HasTile = true;
									tile2.IsHalfBlock = true;
									break;
								case 7:
									tile.TileType = (ushort)ModContent.TileType<RefractingCrystalBlockTile>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									tile.HasTile = true;
									break;
								case 8:
									tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274;
									tile.HasTile = true;
									tile.Slope = (SlopeType)3;
									tile2.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //274;
									tile2.HasTile = true;
									tile2.Slope = (SlopeType)4;
									break;
								case 9:
									tile.LiquidType = 0;
									tile.LiquidAmount = 255;
									tile.HasTile = false;
									WorldGen.SquareTileFrame(k, l, false);

									tile2.LiquidType = 0;
									tile2.LiquidAmount = 255;
									tile2.HasTile = false;
									WorldGen.SquareTileFrame(k2, l, false);
									break;
							}
						}
					}
				}
			}
			for (int y = 0; y < _zeplineWalls.GetLength(0); y++)
			{
				for (int x = 0; x < _zeplineWalls.GetLength(1); x++)
				{
					int k = pyramidPosX + x;
					int l = pyramidPosY + y;
					int k2 = pyramidPosX - x;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						Tile tile2 = Framing.GetTileSafely(k2, l);
						switch (_zeplineWalls[y, x])
						{
							case 0:
								tile.WallType = (ushort)ModContent.WallType<UnsafePyramidWallWall>();  //sandbrick
								tile2.WallType = (ushort)ModContent.WallType<UnsafePyramidWallWall>();
								break;
							case 1:
								tile.WallType = 226; //sandfall 
								tile2.WallType = 226;
								break;
							case 2:
								tile.WallType = 136; //waterfall
								tile2.WallType = 136;
								break;
							case 3:
								break;
							case 4:
								break;
						}
					}
				}
			}
		}
		public static void GenerateCrate(int x, int y, Mod mod)
		{
			int rand = WorldGen.genRand.Next(4);
			if (rand != 3)
			{
				WorldGen.PlaceTile(x, y, 376, true, true, -1, rand);
			}
			else
			{
				WorldGen.PlaceTile(x + 1, y, ModContent.TileType<PyramidCrateTile>());
			}
		}
		public static void GenerateShrineRoom(int x, int y, Mod mod, int type = 0)
		{
			int[,] _structure = {
				{0,0,0,0,0,0,0,1,1,12,1,1,0,0,0,0,0,0,0},
				{0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0},
				{0,0,2,1,1,1,1,1,3,4,3,1,1,1,1,1,2,0,0},
				{0,1,2,4,3,1,1,1,5,2,6,1,1,1,3,4,2,1,0},
				{1,1,5,2,6,1,1,1,1,1,1,1,1,1,5,2,6,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1},
				{8,8,8,8,8,8,8,4,13,13,13,4,8,8,8,8,8,8,8},
				{0,2,8,8,8,10,10,10,10,10,10,10,10,10,8,8,8,2,0},
				{0,2,2,8,8,9,4,4,4,4,4,4,4,11,8,8,2,2,0},
				{0,0,2,2,8,8,8,9,4,4,4,11,8,8,8,2,2,0,0},
				{0,0,0,2,2,8,8,8,8,8,8,8,8,8,2,2,0,0,0},
				{0,0,0,0,2,2,2,8,8,8,8,8,2,2,2,0,0,0,0}
			};
			int PosX = x;  //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = y;
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 1:
									if (confirmPlatforms == 0)
									{
										tile.HasTile = false;
										tile.IsHalfBlock = false;
										tile.Slope = 0;
									}
									break;
								case 2:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274;
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 3:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274;
									tile.Slope = 0;
									tile.IsHalfBlock = true;
									break;
								case 4:
									if (confirmPlatforms == 0)
									{
										tile.HasTile = false;
										tile.IsHalfBlock = false;
										tile.Slope = 0;
										tile.LiquidAmount = 255;
										tile.LiquidType = 0;
									}
									break;
								case 5:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274;
									tile.Slope = (SlopeType)4;
									tile.IsHalfBlock = false;
									break;
								case 6:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274;
									tile.Slope = (SlopeType)3;
									tile.IsHalfBlock = false;
									break;
								case 7:
									if (confirmPlatforms == 1)
									{
										tile.HasTile = false;
										tile.Slope = 0;
										tile.IsHalfBlock = false;
										if (type == 0)
											WorldGen.PlaceTile(k, l, ModContent.TileType<EnchantedSwordShrineTile>(), true, true, -1, 0);
										if (type == 1)
											WorldGen.PlaceTile(k, l, ModContent.TileType<EnchantedPickShrineTile>(), true, true, -1, 0);
									}
									break;
								case 8:
									tile.HasTile = true;
									tile.TileType = 2;
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
								case 9:
									tile.HasTile = true;
									tile.TileType = 2;
									tile.Slope = (SlopeType)1;
									tile.IsHalfBlock = false;
									break;
								case 10:
									if (confirmPlatforms == 0)
									{
										tile.HasTile = false;
										tile.IsHalfBlock = false;
										tile.Slope = 0;
										tile.LiquidAmount = 254;
										tile.LiquidType = 0;
									}
									break;
								case 11:
									tile.HasTile = true;
									tile.TileType = 2;
									tile.Slope = (SlopeType)2;
									tile.IsHalfBlock = false;
									break;
								case 12:
									if (confirmPlatforms == 0)
									{
										tile.HasTile = false;
										tile.IsHalfBlock = false;
										tile.Slope = 0;
										for (int h = 1; h < 50; h++)
										{
											Tile tile2 = Framing.GetTileSafely(k, l - h);
											Tile tile3 = Framing.GetTileSafely(k, l - h - 1);
											Tile tile4 = Framing.GetTileSafely(k, l - h - 2);
											Tile tile5 = Framing.GetTileSafely(k, l - h - 3);
											if (tile2.TileType == ModContent.TileType<PyramidSlabTile>() && tile2.HasTile && tile3.TileType == ModContent.TileType<PyramidSlabTile>() && tile3.HasTile && tile4.TileType == ModContent.TileType<PyramidSlabTile>() && tile4.HasTile && tile5.TileType == ModContent.TileType<PyramidSlabTile>() && tile5.HasTile)
											{
												if (WorldGen.genRand.Next(h) <= WorldGen.genRand.Next(50))
												{
													tile2.HasTile = false;
													tile2.IsHalfBlock = false;
													tile2.Slope = 0;
												}
											}
											else
											{
												break;
											}
										}
									}
									break;
								case 13:
									tile.HasTile = true;
									tile.TileType = (ushort)ModContent.TileType<CursedHive>();
									tile.Slope = 0;
									tile.IsHalfBlock = false;
									break;
							}
						}
					}
				}
			}
		}
		public static bool CanTunnelTile(Tile tile)
		{
			return tile.HasTile && (tile.WallType == (ushort)ModContent.WallType<UnsafePyramidWallWall>() || tile.WallType == (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>())
				&& (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() || tile.TileType == TileID.SandStoneSlab || tile.TileType == (ushort)ModContent.TileType<PyramidBrickTile>() || tile.TileType == (ushort)ModContent.TileType<RoyalGoldBrickTile>() || tile.TileType == (ushort)ModContent.TileType<AncientGoldSpikeTile>());
		}
		public static bool StopTunnelTile(Tile tile)
		{
			return tile.HasTile && (tile.TileType == (ushort)ModContent.TileType<TrueSandstoneTile>() || tile.TileType == (ushort)ModContent.TileType<CursedTumorTile>());
		}
		public static void GeneratePyramidRoom(int x, int y, int direction, Mod mod)
		{
			//direction 0 = left, 1 = right, 2 = up, 3 = down
			if (direction == 0 || direction == 1 || direction == 2 || direction == 3)
			{
				for (int checkSquareX = -12; checkSquareX <= 12; checkSquareX++)
				{
					for (int checkSquareY = -12; checkSquareY <= 12; checkSquareY++)
					{
						Tile tileCheck = Framing.GetTileSafely(x + checkSquareX, y + checkSquareY);
						if (checkSquareX == -12 || checkSquareX == 12 || checkSquareY == -12 || checkSquareY == 12)
						{
							tileCheck.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstoneBrick
						}
						if (checkSquareX == -10 || checkSquareX == 10 || checkSquareY == -10 || checkSquareY == 10)
						{
							tileCheck.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstoneBrick
						}
						tileCheck.WallType = (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>();
					}
				}
				Tile initialTile = Framing.GetTileSafely(x, y);
				int variation = WorldGen.genRand.Next(12);
				if (direction == 0)
				{
					//tile.TileType = 200;
					if (!WorldGen.genRand.NextBool(3))
					{
						for (int checkLeft = 0; checkLeft < 300; checkLeft++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x - checkLeft, y + h);
								if (!CanTunnelTile(checkTile))
								{
									check5++;
								}
								if (StopTunnelTile(checkTile))
								{
									check5 = 5;
								}
								else
									checkTile.HasTile = false;
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,7,7,3,3,3,3,3,3,3,3,3},
							{1,7,7,7,7,7,7,7,0,0,4,8,8,3,3,3,3},
							{1,7,7,7,7,7,0,0,0,0,3,3,3,3,3,3,3},
							{1,7,7,0,0,0,0,0,0,0,0,0,4,8,8,3,3},
							{1,1,7,7,0,0,0,0,0,0,0,0,3,3,3,3,3},
							{2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3},
							{1,1,1,1,1,1,8,8,8,8,8,8,8,3,3,3,3},
							{1,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3,3},
							{1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3},
							{1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3},
							{1,1,8,5,8,8,8,8,6,8,8,8,8,8,8,8,8}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.IsHalfBlock = true;
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,7,0,0,0,0,0,7,1,1,1,1,1},
							{1,2,1,7,7,0,0,0,0,0,0,0,7,7,1,2,1},
							{1,1,7,0,0,0,0,0,0,0,0,0,0,0,7,1,1},
							{1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1},
							{1,7,0,0,0,0,0,7,0,7,0,0,0,0,0,7,1},
							{7,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,7},
							{0,0,0,0,0,0,2,7,7,7,2,0,0,0,0,0,0},
							{0,0,0,0,7,7,7,1,1,1,7,7,7,0,0,9,9},
							{0,0,0,0,0,2,7,1,0,1,7,2,0,0,0,6,9},
							{0,0,0,0,7,7,7,1,1,1,7,7,7,0,0,3,3},
							{0,0,0,0,0,0,2,7,7,7,2,0,0,0,0,0,3},
							{7,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,7},
							{1,7,0,0,0,0,0,7,0,7,0,0,0,0,0,7,1},
							{1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1},
							{1,1,7,0,0,0,0,0,0,0,0,0,0,0,7,1,1},
							{1,2,1,7,7,0,0,0,0,0,0,0,7,7,1,2,1},
							{1,1,1,1,1,7,0,0,0,0,0,7,1,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.IsHalfBlock = true;
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //woodenspike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,3,1,1,1,1,1,1,3,1,1,1},
							{1,0,0,0,0,0,3,0,0,0,0,3,3,3,3,3,0},
							{1,0,0,0,3,3,3,3,3,0,0,3,1,1,1,3,0},
							{1,0,0,0,3,1,1,1,3,0,0,0,1,1,1,0,0},
							{1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0},
							{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1},
							{0,0,0,0,0,0,5,0,0,0,0,3,3,3,3,3,0},
							{0,0,0,1,1,1,1,1,1,0,0,0,3,0,0,0,0},
							{3,0,0,0,3,3,3,3,0,0,0,0,3,0,3,0,0},
							{3,0,0,0,0,0,3,0,0,3,8,8,8,8,3,0,0},
							{3,8,8,8,3,0,3,0,0,3,8,8,8,8,3,8,3},
							{3,8,8,8,3,8,8,8,8,3,8,8,8,8,3,8,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.IsHalfBlock = true;
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 16); //anvil
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 302); //glass kiln
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //woodenspike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = true;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
							{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
							{0,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,0},
							{0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0},
							{0,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,0},
							{0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,7,0},
							{0,0,0,0,0,0,0,3,3,3,0,0,0,3,3,3,3},
							{0,0,0,0,0,0,2,2,2,2,2,0,0,0,2,2,3},
							{0,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,3},
							{0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0},
							{0,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,0},
							{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
							{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.IsHalfBlock = true;
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 16); //anvil
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = true;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,3,5,0,5,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,9,9,9,9,9,9,0,0,0,0,0,0,0,0,4,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4},
							{0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4},
							{0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3},
							{0,0,0,0,0,0,0,0,4,0,3,3,3,3,3,3,3},
							{0,0,0,0,0,0,0,0,4,4,3,3,3,3,3,3,3},
							{0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2},
							{0,0,0,0,0,4,4,0,3,3,3,3,3,3,3,3,3},
							{0,0,0,0,4,4,4,4,3,3,3,3,3,3,3,3,3},
							{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 16); //anvil
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,0,6,0,6,6,6,6,6,6,6,6,6,0,6,0,3},
							{3,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,3},
							{3,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,3},
							{3,0,0,0,6,0,0,0,2,0,0,0,6,0,0,0,3},
							{3,0,6,0,6,6,6,6,2,6,6,6,6,0,6,0,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //spike
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,5,5,0,0,0,0,0,5,5,1,1,1,1},
							{1,1,5,5,5,0,0,0,0,0,0,0,5,5,5,1,1},
							{1,5,5,5,0,0,0,0,0,0,0,0,0,5,5,5,1},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5},
							{0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0},
							{0,0,0,0,0,3,3,3,3,3,3,3,8,8,8,8,8},
							{0,0,0,0,3,3,3,3,3,3,3,3,3,8,8,8,8},
							{0,0,0,3,3,3,3,3,3,3,3,3,3,3,8,8,8},
							{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,3,2,3,2,0,3,2,2,2,3,0,2,3,2,3,3},
							{3,3,2,3,0,0,3,2,0,2,3,0,0,3,2,3,3},
							{3,3,2,3,6,0,3,2,2,2,3,6,0,3,2,3,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = true;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{5,5,5,2,1,3,0,0,0,0,0,3,1,2,5,5,5},
							{5,0,5,2,1,3,0,0,0,0,0,3,1,2,5,0,5},
							{5,5,5,2,2,3,0,0,0,0,0,3,2,2,5,5,5},
							{2,2,2,1,1,3,0,0,0,0,0,3,1,1,2,2,2},
							{1,1,2,1,3,0,0,0,0,0,0,0,3,1,2,1,1},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,5,1,1,1,5,0,0,0,0,0,0},
							{0,0,0,0,0,0,5,1,3,1,5,0,0,0,0,0,0},
							{0,0,0,0,0,0,5,1,1,1,5,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,5,5,5,0,0,0,0,7,0,0},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{1,1,2,1,3,0,0,0,0,0,0,0,3,1,2,0,0},
							{2,2,2,1,1,3,0,0,0,0,0,3,1,1,2,2,2},
							{5,5,5,2,2,3,0,0,0,0,0,3,2,2,5,5,5},
							{5,0,5,2,1,3,0,0,0,0,0,3,0,2,5,0,5},
							{5,5,5,2,1,3,0,0,0,0,0,3,0,2,5,5,5}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = true;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,5,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,5,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,5,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,5,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,0,5,4,2,2,2,2,2,2,2,2,2},
							{3,0,0,0,0,0,0,4,2,3,3,3,3,3,3,3,3},
							{2,2,0,0,0,0,0,4,2,0,0,0,0,0,0,0,0},
							{3,3,3,0,0,0,0,5,3,0,0,0,0,0,0,0,0},
							{2,2,2,2,0,0,0,0,3,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,0,0,0,3,0,0,0,0,6,0,7,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 53; //sand
												tile.HasTile = true;
												break;
											case 5:
												tile.TileType = 53; //sand
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = true;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,2,3,2,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,0,2,0,0,0,0,1,0,0},
							{0,2,3,2,0,0,0,0,0,0,0,0,0,0,1,0,0},
							{0,0,2,0,0,0,0,0,4,0,0,0,0,2,3,2,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0},
							{0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0},
							{10,0,0,0,0,0,0,8,0,12,10,10,9,0,13,14,10},
							{10,10,0,11,0,13,13,14,14,10,10,10,14,14,14,10,10},
							{10,10,10,14,14,14,14,14,10,10,10,10,15,14,15,15,10},
							{10,15,15,15,14,15,15,15,15,15,15,15,15,15,15,15,10}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 1:
												tile.HasTile = true;
												tile.TileType = 213;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 2:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 3:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 4:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 241, true, true, -1, 8);
												}
												break;
											case 5:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 241, true, true, -1, 1);
												}
												break;
											case 6:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 241, true, true, -1, 0);
												}
												break;
											case 7:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>(), true, true, -1, 0);
												}
												break;
											case 8:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 85, true, true, -1, 2);
												}
												break;
											case 9:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 85, true, true, -1, 8);
												}
												break;
											case 10:
												tile.HasTile = true;
												tile.TileType = 2;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 11:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 85, true, true, -1, 1);
												}
												break;
											case 12:
												tile.HasTile = true;
												tile.TileType = 2;
												tile.Slope = 0;
												tile.IsHalfBlock = true;
												break;
											case 13:
												tile.HasTile = true;
												tile.TileType = 1;
												tile.Slope = 0;
												tile.IsHalfBlock = true;
												break;
											case 14:
												tile.HasTile = true;
												tile.TileType = 1;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 15:
												tile.HasTile = true;
												tile.TileType = 0;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0},
							{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1},
							{0,0,0,0,2,0,0,2,2,2,0,0,0,2,2,2,1},
							{0,2,0,0,2,0,0,2,2,2,2,0,2,2,2,2,1},
							{2,2,0,0,2,2,0,2,2,2,2,2,2,2,2,2,1},
							{2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,1},
							{2,2,2,0,2,2,2,2,2,2,2,2,2,3,2,0,0},
							{2,2,0,0,2,2,0,2,2,2,2,2,2,1,1,1,0},
							{2,2,0,0,2,2,0,2,2,1,1,0,1,1,1,1,1},
							{2,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<CursedHive>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 1:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 2:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>(), true, true, -1, 0);
												}
												break;
										}
									}
								}
							}
						}
					}
				}
				if (direction == 1)
				{
					//tile.TileType = 100;
					if (!WorldGen.genRand.NextBool(3))
					{
						for (int checkRight = 0; checkRight < 300; checkRight++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x + checkRight, y + h);
								if (!CanTunnelTile(checkTile))
								{
									check5++;
								}
								if (StopTunnelTile(checkTile))
								{
									check5 = 5;
								}
								else
									checkTile.HasTile = false;
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{3,1,1,1,1,1,1,1,1,2,3,3,3,3,3,3,3},
							{3,0,0,0,0,0,0,2,1,2,3,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,2,1,2,3,0,9,9,0,0,3},
							{3,0,0,0,0,0,0,2,1,2,3,0,6,9,0,0,3},
							{3,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2},
							{3,0,0,2,1,0,0,0,1,1,1,1,1,1,1,1,1},
							{3,0,0,2,1,0,0,0,0,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,0,0,9,9,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,4,0,9,9,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,7,4,5,9,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,2,2,2,2,2,0,0,3,0,0,0,0},
							{3,0,0,2,1,1,1,1,1,2,0,0,3,0,0,2,3},
							{2,0,0,2,2,2,2,2,1,2,0,0,3,0,0,2,3},
							{0,0,0,0,0,0,0,2,1,2,0,0,3,0,0,2,3},
							{0,4,4,4,4,0,0,2,1,2,0,0,0,0,0,2,3},
							{7,7,4,4,4,4,0,2,1,2,0,0,0,0,0,2,3},
							{7,7,7,7,7,7,7,2,1,2,0,0,0,0,0,2,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 331; //silver coin
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{3,1,1,1,1,2,1,4,4,4,4,4,1,1,1,1,1},
							{3,3,4,4,4,2,1,1,1,1,1,4,4,1,1,1,1},
							{3,3,3,4,4,2,2,2,2,2,1,4,4,4,1,1,1},
							{3,3,3,3,4,4,4,4,0,0,1,0,4,0,0,1,1},
							{3,3,3,3,3,4,0,0,0,0,0,0,0,0,0,0,1},
							{3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2},
							{3,0,0,0,3,3,3,3,3,3,3,3,2,1,1,1,1},
							{3,9,9,0,3,3,3,3,3,3,3,3,2,1,0,0,1},
							{3,6,9,0,3,3,3,3,3,3,3,3,2,1,0,0,1},
							{3,3,3,3,3,3,3,3,3,3,3,3,2,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,1},
							{1,1,1,1,1,2,2,2,2,4,4,4,1,1,2,2,1},
							{1,0,0,0,1,1,2,2,2,4,4,4,4,1,2,2,2},
							{0,7,7,7,0,1,1,1,1,4,4,4,4,1,1,1,2},
							{7,7,7,7,7,1,1,1,1,4,4,0,0,0,0,1,1},
							{7,7,7,7,7,1,1,1,1,4,0,0,0,0,0,0,0},
							{2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
							{2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0},
							{2,2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{4,0,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,6,9,0,0,0,0,0,0,0,0,0,0,0,0,1},
							{0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
							{8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1},
							{8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,2},
							{8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,2,2}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,2,2,2,0,0,0,0,0,0,0,0,0,5,0,5,0},
							{1,1,1,1,1,0,0,0,0,0,0,2,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1},
							{5,0,5,0,0,0,0,0,0,0,0,0,0,0,0,2,1},
							{1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,2,2},
							{1,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{0,0,9,0,0,0,0,2,2,2,2,2,0,0,0,2,3},
							{2,2,2,2,2,2,8,8,8,2,8,8,8,8,8,2,3},
							{3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,2,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 93; //tikitorch
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 102, true, true, -1); //throne
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{3,3,3,2,3,0,0,0,0,0,0,0,0,0,0,0,3},
							{0,0,3,2,3,0,0,0,0,0,0,0,0,0,0,0,3},
							{0,0,3,2,3,0,0,0,0,0,3,3,3,3,3,3,3},
							{0,0,3,2,3,0,0,0,0,0,3,2,2,2,2,2,2},
							{0,0,3,2,3,6,0,0,0,0,0,2,0,0,0,0,0},
							{0,0,0,2,3,3,3,3,0,0,0,0,0,4,8,4,0},
							{0,0,0,2,2,2,2,0,0,0,0,0,0,3,3,3,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,0,7,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,3,3,3,3,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,2,2,2,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,2,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0},
							{8,8,8,8,3,2,8,8,8,8,8,8,8,8,8,8,8}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.IsHalfBlock = true;
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = true;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,0,6,0,6,6,6,6,6,6,6,6,6,0,6,0,3},
							{3,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,3},
							{3,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,3},
							{3,0,0,0,6,0,0,0,2,0,0,0,6,0,0,0,3},
							{3,0,6,0,6,6,6,6,2,6,6,6,6,0,6,0,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //spike
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,3,3,2,3,3,3,3,3,7,3,3},
							{4,4,4,4,2,2,2,2,2,2,2,2,2,7,7,7,2},
							{4,4,4,0,0,3,3,3,2,3,3,3,7,3,3,3,3},
							{4,4,0,0,0,0,2,2,2,2,2,7,7,7,2,2,2},
							{4,0,0,0,0,0,0,3,2,3,7,3,3,3,3,3,3},
							{4,0,0,0,0,0,0,0,2,7,7,7,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,2,2,2,7,7,7,2,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,7,3,2,3,0,0,0,0,0,0,0},
							{2,2,2,7,7,7,2,2,2,2,2,8,8,8,8,8,8},
							{3,3,3,3,7,3,3,3,2,3,3,3,8,8,8,8,8},
							{2,7,7,7,2,2,2,2,2,2,2,2,2,8,8,8,8},
							{3,3,7,3,3,3,3,3,2,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //spike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 240, true, true, -1, WorldGen.genRand.Next(16, 18)); //hanging skeleton
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{4,4,4,4,4,0,0,0,4,4,7,7,7,7,7,7,7},
							{4,4,0,0,0,0,0,0,0,4,7,3,3,3,3,3,3},
							{4,0,0,9,0,0,0,0,0,0,0,0,7,7,7,7,7},
							{0,0,0,0,0,0,0,0,0,0,0,0,7,3,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7},
							{6,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0},
							{1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0},
							{7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,7,0,0,0,0,0,0,0,0,0,0},
							{7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,7,0,0,0,0,0,0,0,0},
							{7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,4},
							{3,3,3,3,3,3,3,3,3,3,7,2,2,7,0,4,4},
							{7,7,7,7,7,7,7,7,7,7,7,2,2,7,7,7,7},
							{3,3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 240, true, true, -1, WorldGen.genRand.Next(16, 18)); //hanging skeleton
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,1,1,2,2,2,2,2,3,3,1,1,1,1,1,1,3},
							{3,1,2,2,2,2,2,3,3,1,1,0,0,0,9,9,3},
							{3,3,3,3,3,3,3,3,1,1,0,0,0,0,0,0,3},
							{3,1,1,1,1,1,1,1,1,0,0,0,4,4,7,0,3},
							{3,9,9,0,0,0,0,0,0,0,0,0,4,1,1,1,3},
							{3,9,0,0,0,5,0,0,0,0,0,4,1,1,0,0,0},
							{3,0,0,0,0,0,0,0,4,4,4,1,1,0,0,0,0},
							{3,0,0,0,4,4,4,4,4,4,1,1,0,0,0,0,0},
							{3,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,3},
							{3,9,0,0,0,0,0,0,0,0,0,0,0,1,1,2,3},
							{3,9,9,0,0,0,0,0,0,0,0,0,1,1,2,2,3},
							{3,9,9,0,0,0,0,0,0,0,0,1,1,2,2,2,3},
							{3,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 332; //coins
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 240, true, true, -1, WorldGen.genRand.Next(16, 18)); //hanging skeleton
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,1,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0},
							{3,4,0,0,0,5,6,6,0,0,0,0,0,0,0,0,0},
							{7,7,0,0,5,6,8,0,0,0,0,0,0,0,0,0,0},
							{7,7,0,5,6,8,5,6,6,9,0,0,0,0,0,0,0},
							{7,7,5,6,8,5,6,6,6,6,9,0,0,4,0,0,0},
							{7,6,6,8,5,6,6,0,0,6,6,9,0,4,0,0,0},
							{6,6,6,2,2,2,2,10,0,6,6,6,6,7,7,0,0},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,4,0},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7},
							{6,6,6,0,0,6,6,6,6,6,6,6,6,6,6,6,7},
							{6,6,6,11,0,6,6,6,6,6,6,6,6,6,6,6,6},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 1:
												tile.HasTile = true;
												tile.TileType = 188;
												tile.Slope = 0;
												tile.IsHalfBlock = true;
												break;
											case 2:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = true;
												break;
											case 3:
												tile.HasTile = true;
												tile.TileType = 53;
												tile.Slope = (SlopeType)1;
												tile.IsHalfBlock = false;
												break;
											case 4:
												tile.HasTile = true;
												tile.TileType = 188;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 5:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.Slope = (SlopeType)2;
												tile.IsHalfBlock = false;
												break;
											case 6:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 7:
												tile.HasTile = true;
												tile.TileType = 53;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 8:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.Slope = (SlopeType)3;
												tile.IsHalfBlock = false;
												break;
											case 9:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.Slope = (SlopeType)1;
												tile.IsHalfBlock = false;
												break;
											case 10:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>(), true, true, -1, 0);
												}
												break;
											case 11:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>(), true, true, -1, 0);
												}
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
							{1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
							{1,2,2,1,1,2,1,1,2,2,2,2,2,1,1,1,0},
							{1,1,2,2,1,2,1,2,2,1,1,1,1,1,1,0,0},
							{0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,2,2,2,3,0,2,2,0,0,0,0,4,0,0,5,5},
							{5,5,2,2,2,2,2,2,2,5,5,5,5,5,5,5,6},
							{6,6,6,2,6,6,6,2,2,2,2,6,7,7,7,7,6},
							{6,6,2,2,6,6,6,2,2,6,7,7,8,0,0,10,7},
							{6,6,2,6,6,6,6,6,2,7,7,11,0,9,0,11,7},
							{6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,6}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 1:
												tile.HasTile = true;
												tile.TileType = 192;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 2:
												tile.HasTile = true;
												tile.TileType = 191;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>(), true, true, -1, 0);
												}
												break;
											case 4:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 86, true, true, -1, 0);
												}
												break;
											case 5:
												tile.HasTile = true;
												tile.TileType = 2;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 6:
												tile.HasTile = true;
												tile.TileType = 0;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 7:
												tile.HasTile = true;
												tile.TileType = 1;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 8:
												tile.HasTile = true;
												tile.TileType = 1;
												tile.Slope = (SlopeType)3;
												tile.IsHalfBlock = false;
												break;
											case 9:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>(), true, true, -1, 0);
												}
												break;
											case 10:
												tile.HasTile = true;
												tile.TileType = 1;
												tile.Slope = (SlopeType)4;
												tile.IsHalfBlock = false;
												break;
											case 11:
												tile.HasTile = true;
												tile.TileType = 1;
												tile.Slope = 0;
												tile.IsHalfBlock = true;
												break;
										}
									}
								}
							}
						}
					}

				}
				if (direction == 2)
				{
					//tile.TileType = 150;
					if (!WorldGen.genRand.NextBool(3))
					{
						for (int checkUp = 0; checkUp < 300; checkUp++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x + h, y - checkUp);
								if (!CanTunnelTile(checkTile))
								{
									check5++;
								}
								if (StopTunnelTile(checkTile))
								{
									check5 = 5;
								}
								else
									checkTile.HasTile = false;
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{3,3,3,4,4,4,0,0,0,0,0,0,2,3,3,3,3},
							{2,2,2,2,4,0,0,0,0,0,0,0,2,4,4,4,3},
							{3,4,4,4,0,0,0,0,0,0,0,0,2,4,4,4,3},
							{3,4,4,4,0,0,2,2,2,2,2,2,2,0,4,4,3},
							{3,4,4,0,0,0,0,0,4,4,4,4,0,0,0,4,3},
							{3,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,3},
							{3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,3},
							{4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{3,3,3,3,3,2,0,0,0,0,0,0,0,0,0,2,3},
							{3,0,0,7,0,2,0,0,0,0,0,0,0,0,2,2,3},
							{3,7,7,7,0,2,0,0,0,0,0,0,0,0,0,0,3},
							{3,7,7,7,7,2,0,0,0,0,0,0,0,0,0,0,3},
							{3,7,7,7,7,2,0,0,0,0,0,0,0,9,9,0,3},
							{3,7,7,7,7,2,2,2,2,2,2,2,0,6,9,0,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,1,1},
							{2,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
							{2,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,2,2,2,2,2,2,2,1,1,1,1,2},
							{2,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,4,4,7,7,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,0,0,4,7,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,0,0,4,7,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,0,0,0,7,2,2,0,0,0,4,2},
							{2,4,0,0,0,6,0,0,0,7,2,2,0,0,0,4,2},
							{2,4,4,0,0,9,9,0,0,7,2,2,0,0,4,7,2},
							{2,7,4,0,0,0,0,0,0,7,2,2,7,4,4,7,2},
							{2,7,7,7,7,7,7,7,7,7,2,2,7,7,7,7,2},
							{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,2,4,0,0,0,0,0,4,2,3,3,3,3},
							{3,4,2,3,2,4,0,0,0,0,0,4,2,3,2,4,3},
							{4,4,2,3,2,4,0,0,0,0,0,4,2,3,2,4,4},
							{4,0,2,3,4,0,0,0,0,0,0,0,4,3,2,0,4},
							{4,0,2,3,4,0,0,0,0,0,0,0,4,3,2,0,4},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,9,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0},
							{3,3,3,2,0,0,0,0,0,0,0,0,0,2,3,3,3},
							{3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{2,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,2},
							{7,0,0,7,0,0,7,3,7,3,7,0,0,7,0,0,7},
							{7,0,7,7,7,0,7,3,2,3,7,0,7,7,7,0,7},
							{7,7,2,7,2,7,7,3,2,3,7,7,2,7,2,7,7}
						};

						int PosX = x - (int)(.5f * _pyramidRoom.GetLength(1));
						int PosY = y - (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,2,0,0,0,0,0,2,1,1,1,1,1},
							{1,1,1,4,4,2,0,0,0,0,0,2,0,4,1,1,1},
							{1,4,4,0,4,2,1,1,1,1,1,2,0,4,4,4,1},
							{1,4,0,0,4,4,4,0,0,0,0,0,4,4,4,4,1},
							{4,4,0,0,0,4,0,0,0,0,0,4,4,4,4,4,4},
							{4,0,0,0,0,4,0,0,0,0,0,4,4,4,4,4,4},
							{4,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4},
							{0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{4,0,2,0,0,0,0,0,0,0,0,0,0,4,2,4,4},
							{4,4,2,0,0,0,0,0,0,0,0,0,0,0,2,4,4},
							{4,4,2,0,0,0,0,0,0,0,0,0,0,0,2,4,4},
							{0,4,2,0,0,0,0,0,0,0,0,0,0,0,2,4,0},
							{0,0,2,8,8,8,8,8,8,8,8,8,8,8,2,0,7},
							{7,0,2,8,8,8,8,8,8,8,8,8,8,8,2,7,7},
							{7,7,2,8,8,8,2,8,8,8,2,8,8,8,2,7,7},
							{1,1,2,2,2,2,2,8,8,8,2,2,2,2,2,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{4,4,4,4,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{2,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2},
							{4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4},
							{2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{8,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,8},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,0,0,0,0,0,0,6,0,0,0,0,0,0,2,2},
							{0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0},
							{2,2,2,0,0,0,2,3,2,3,2,0,0,0,2,2,2},
							{0,0,0,0,0,0,0,3,2,3,0,0,0,0,0,0,0},
							{2,2,2,2,0,0,0,3,2,3,0,0,0,2,2,2,2},
							{8,8,8,8,8,8,3,3,2,3,3,8,8,8,8,8,8}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.IsHalfBlock = true;
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 77); //hellforge
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,6,0,0,0,0,0,0,0,0,0,0,0,0,6,0,5},
							{2,9,9,9,0,0,0,0,0,0,0,0,0,9,9,9,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //spike
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //spike
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,0,0,0,0,0,3,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,3,3,3,2,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,3,2,3,2,3},
							{3,0,0,0,0,0,0,0,4,0,0,2,3,2,3,2,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,3,2,3,2,3},
							{3,6,0,0,5,0,0,0,0,0,0,2,3,2,3,2,3},
							{3,2,1,3,3,3,3,3,3,3,2,2,3,2,3,2,3},
							{3,2,1,3,2,2,2,3,2,3,2,3,3,2,3,2,3},
							{3,2,1,3,3,3,2,3,2,3,2,3,2,2,3,2,3},
							{3,2,1,1,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,2,3,3,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,2,2,2,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,3,3,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,0,0,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,7,0,3,2,3,2,3,2,2,2,2,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												if (confirmPlatforms == 1)
													WorldGen.PlaceTile(k, l, 240, true, true, -1, WorldGen.genRand.Next(16, 18)); //hanging skeleton
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 215); //campfire
												break;
											case 6:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{7,7,7,7,7,2,0,0,0,0,0,2,7,7,7,7,7},
							{7,0,0,0,7,2,0,0,0,0,9,2,7,0,0,0,7},
							{0,0,0,0,7,2,0,0,0,0,0,2,7,0,0,0,0},
							{0,0,0,0,7,2,0,0,0,0,0,2,0,0,5,0,0},
							{0,0,0,0,7,2,9,0,0,0,0,2,0,0,0,0,0},
							{0,0,5,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7},
							{0,0,2,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,0,2,0,0,0,0,0,7,0,0,0,0,0,0,0,3},
							{0,0,2,0,0,0,0,0,7,0,0,0,0,0,0,0,7},
							{0,0,2,0,0,0,0,0,7,0,0,0,0,0,0,0,7},
							{6,0,2,0,0,0,0,0,7,7,0,0,0,0,0,0,7},
							{9,9,2,0,0,0,0,7,3,7,0,0,0,0,0,7,7},
							{7,7,2,7,7,7,7,3,3,3,3,7,7,7,7,7,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 240, true, true, -1, WorldGen.genRand.Next(16, 18)); //hanging skeleton
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,2,0,0,0,0,0,2,3,3,3,3,3},
							{3,7,7,7,3,2,0,0,0,0,0,2,3,2,2,2,2},
							{3,7,0,7,3,2,0,0,0,0,0,2,3,2,0,0,0},
							{3,7,0,7,3,2,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,2,2,2,2,2,2,2,2,2,2,3,2,0,0,0},
							{0,0,0,2,3,2,3,3,3,3,3,2,3,2,0,0,0},
							{0,0,0,2,3,2,3,7,7,7,3,2,3,0,0,0,0},
							{0,0,0,0,3,2,3,7,0,7,3,2,3,0,0,6,0},
							{3,0,0,0,0,2,3,7,0,7,3,2,0,0,0,9,3},
							{3,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,3},
							{2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,7,2},
							{3,3,7,0,0,0,0,0,0,0,0,0,0,0,7,3,3},
							{3,0,3,7,0,0,0,0,0,0,0,0,0,7,3,2,3},
							{3,3,3,2,3,2,0,0,0,0,0,2,3,2,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 240, true, true, -1, WorldGen.genRand.Next(16, 18)); //hanging skeleton
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0},
							{0,2,2,2,0,0,1,1,1,1,1,0,0,2,2,2,0},
							{0,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,0},
							{0,0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0},
							{0,3,0,2,0,1,1,1,1,1,1,1,0,2,0,0,0},
							{0,3,0,0,0,1,1,1,1,1,1,1,0,0,0,3,0},
							{0,3,0,0,1,1,1,1,1,1,1,1,1,0,0,3,0},
							{0,3,0,0,1,1,1,1,1,1,1,1,1,0,0,3,0},
							{0,3,4,1,1,1,1,1,1,1,1,1,1,1,1,3,0},
							{0,1,4,1,1,1,1,1,1,1,1,1,1,1,1,3,0},
							{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
							{0,1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
							{0,1,7,7,1,1,1,1,1,1,1,1,1,1,1,1,0},
							{0,1,1,1,1,1,1,1,6,1,1,1,1,1,1,1,0},
							{0,0,1,3,1,1,0,0,0,0,0,1,1,3,1,0,0},
							{0,0,3,3,3,0,0,2,2,2,0,0,3,3,3,0,0},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												tile.HasTile = true;
												tile.TileType = 2;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 1:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 2:
												tile.HasTile = true;
												tile.TileType = 0;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 3:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 4:
												tile.HasTile = true;
												tile.TileType = 52;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 5:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>(), true, true, -1, 0);
												}
												break;
											case 6:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 304, true, true, -1, 0);
												}
												break;
											case 7:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,2,1,1,1,1,1,1,1,1,1,1,1,2,1,0},
							{0,2,2,1,1,1,1,1,1,1,1,1,1,1,2,1,0},
							{0,2,2,1,1,1,1,1,1,1,3,1,1,1,2,1,0},
							{0,2,2,1,1,1,1,1,1,4,4,4,4,1,2,2,0},
							{0,0,2,2,1,1,2,1,1,1,1,1,1,2,2,2,0},
							{0,0,0,2,1,1,2,1,1,1,1,1,0,2,2,2,0},
							{0,0,0,2,1,1,2,1,1,2,1,1,0,2,2,0,0},
							{0,0,0,0,2,1,2,1,2,2,1,0,0,0,2,0,0},
							{0,0,0,0,2,2,2,2,2,2,0,0,0,0,2,0,0},
							{0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<CursedHive>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 1:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 2:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>(), true, true, -1, 0);
												}
												break;
											case 4:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
										}
									}
								}
							}
						}
					}

				}
				if (direction == 3)
				{
					//tile.TileType = 50;
					if (!WorldGen.genRand.NextBool(3))
					{
						for (int checkDown = 0; checkDown < 300; checkDown++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x + h, y + checkDown);
								if (!CanTunnelTile(checkTile))
								{
									check5++;
								}
								if (StopTunnelTile(checkTile))
								{
									check5 = 5;
								}
								else
									checkTile.HasTile = false;
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{7,7,7,7,7,4,4,4,4,2,3,3,3,3,3,3,3},
							{3,3,3,3,7,4,4,4,4,2,3,2,2,2,2,2,3},
							{2,2,2,3,7,4,4,4,0,2,3,3,3,3,3,2,3},
							{4,2,3,3,2,7,4,4,0,2,2,2,2,2,2,2,3},
							{4,2,2,2,2,3,7,0,0,0,0,0,3,3,3,3,3},
							{4,4,3,3,3,3,7,0,0,0,9,9,3,4,4,4,4},
							{4,4,4,7,3,7,0,0,0,0,6,9,3,0,4,4,4},
							{4,4,7,2,3,7,0,0,3,3,3,3,3,0,7,7,7},
							{4,4,7,2,3,2,0,0,0,0,0,0,0,0,7,2,2},
							{4,7,3,3,3,3,3,0,0,0,0,0,0,0,7,2,3},
							{4,0,7,2,3,2,0,0,0,0,0,7,7,7,7,2,3},
							{0,0,7,2,3,0,0,0,0,0,0,7,2,2,2,2,3},
							{0,0,0,7,3,0,0,0,0,0,0,7,2,3,3,3,3},
							{7,0,0,0,0,0,0,0,0,0,0,7,2,3,3,3,3},
							{3,7,0,0,9,9,0,0,0,0,0,7,2,3,3,3,3},
							{3,2,7,0,9,9,0,0,0,0,0,7,2,3,3,3,3},
							{3,2,3,7,5,9,0,0,0,0,0,7,2,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 0;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{2,1,1,2,2,1,1,1,1,1,1,1,2,2,1,1,2},
							{1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1},
							{1,2,2,2,0,0,0,0,0,0,4,4,4,2,2,2,1},
							{2,2,2,0,0,0,0,0,0,0,0,4,4,4,2,2,2},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,4,4,2,2},
							{3,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,3},
							{3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{4,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
							{4,0,0,0,0,1,1,1,1,2,1,1,1,0,0,0,0},
							{0,0,0,0,0,0,0,7,1,1,1,1,1,1,0,0,8},
							{0,0,0,0,0,6,0,7,1,1,1,1,1,1,1,8,8},
							{9,9,9,9,9,1,1,1,1,1,1,1,1,1,1,1,8},
							{1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1},
							{1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1},
							{1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, WorldGen.genRand.Next(71)); //random statue
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{3,4,4,4,4,4,4,0,3,3,3,3,3,3,3,3,3},
							{3,4,4,4,4,0,0,0,0,2,2,3,2,2,2,2,2},
							{3,4,0,0,0,0,0,0,0,0,2,3,2,4,4,4,4},
							{3,0,0,0,0,0,0,0,0,0,2,3,2,0,4,4,4},
							{3,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0,4},
							{3,0,0,0,0,0,0,0,0,0,0,3,2,0,0,0,0},
							{3,0,5,0,0,0,0,0,0,0,0,3,2,0,0,0,0},
							{3,3,3,3,3,3,9,9,9,9,9,3,0,0,0,0,0},
							{3,2,2,2,2,0,0,0,0,0,0,3,0,0,0,0,0},
							{3,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,7,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0},
							{3,7,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2,3},
							{3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2,2},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //wooden spike
												tile.HasTile = true;
												break;
											case 8:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //heart crystal
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{1,4,4,0,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4},
							{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{1,0,0,0,2,2,2,2,2,2,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,4,4,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,0,4,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,2,2,0,0,2,0,0},
							{2,2,2,2,2,2,2,0,0,0,2,2,0,0,2,0,0},
							{1,4,4,0,0,0,0,0,0,0,2,2,4,4,2,6,0},
							{1,4,0,0,0,0,0,0,0,0,2,2,0,0,2,9,9},
							{1,0,0,0,0,0,0,0,0,0,2,2,0,0,2,0,0},
							{1,0,0,0,2,2,2,2,2,2,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,0,2,8,8,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,0,2,8,8,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,0,2,8,8,2,0,0},
							{1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,2}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1},
							{0,6,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{3,3,3,3,3,0,0,0,0,0,0,1,0,1,1,1,1},
							{3,2,2,2,2,2,0,0,0,0,1,0,0,0,1,1,1},
							{3,3,2,1,1,1,1,0,0,0,0,1,0,1,0,0,0},
							{2,2,2,1,0,0,0,0,0,0,1,0,1,0,0,1,0},
							{0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,1,0},
							{0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,1,2,1,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,3,2,0,0,0},
							{0,0,9,0,0,0,0,0,0,0,0,0,3,2,0,0,0},
							{2,2,2,2,2,0,0,0,0,0,0,0,3,2,0,0,0},
							{3,3,3,3,0,0,0,0,0,0,0,0,3,2,0,6,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 354); //bewitching table
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,6,0,0,0,0,0,0,0,0,0,0,0,0,6,0,5},
							{2,9,9,9,0,0,0,0,0,0,0,0,0,9,9,9,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //spike
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.TileType = (ushort)ModContent.TileType<AncientGoldSpikeTile>(); //spike
												tile.HasTile = true;
												break;
											case 6:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0},
							{2,2,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0},
							{4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,6,0},
							{2,2,2,0,0,0,0,0,0,0,0,0,4,4,2,2,2},
							{4,4,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{2,2,2,2,0,0,0,0,0,0,0,0,0,0,4,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4},
							{2,2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{2,2,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2},
							{0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 355); //alchemy table
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{4,3,3,3,0,0,0,0,3,0,0,0,0,3,3,3,4},
							{4,4,3,3,5,0,5,0,3,5,0,5,0,3,3,4,4},
							{4,4,4,3,3,3,3,3,3,3,3,3,3,3,4,4,4},
							{4,4,4,4,3,3,3,3,3,3,3,3,3,4,4,4,4},
							{4,4,4,0,0,3,3,3,3,3,3,3,0,0,4,4,4},
							{4,4,4,1,0,0,3,3,3,3,3,0,0,1,4,4,4},
							{4,4,0,1,1,0,0,3,3,3,0,0,1,1,0,4,4},
							{4,0,0,0,1,1,0,0,3,0,0,1,1,0,0,0,4},
							{4,0,1,0,0,1,1,0,0,0,1,1,0,0,1,0,4},
							{0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0},
							{0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0},
							{0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{3,3,3,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
							{1,2,2,3,2,1,1,1,2,2,2,2,2,2,2,2,1},
							{1,2,3,3,2,0,0,0,0,0,0,0,0,4,4,2,1},
							{1,2,2,3,2,0,0,0,0,0,0,0,0,0,4,2,1},
							{1,2,2,2,2,5,0,0,0,0,0,0,0,0,0,2,1},
							{1,2,3,2,2,1,1,1,1,1,1,1,1,0,0,2,1},
							{1,2,3,3,2,2,2,2,2,2,2,2,0,0,0,2,1},
							{1,2,3,2,2,1,1,1,1,2,2,0,0,0,0,2,1},
							{1,2,2,2,2,2,2,2,2,2,0,0,0,0,0,2,1},
							{1,2,2,4,4,4,0,0,0,0,0,0,0,0,2,2,1},
							{1,2,2,4,0,0,0,0,0,0,0,0,0,0,2,2,1},
							{1,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,1},
							{1,2,2,1,6,0,0,0,0,0,0,6,0,1,2,2,1},
							{1,2,2,1,1,1,0,0,0,0,0,1,1,1,2,2,1},
							{1,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,1},
							{1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												break;
											case 1:
												tile.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>(); //274; //sandstoneslab
												tile.HasTile = true;
												break;
											case 2:
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>(); //pyramid slab
												tile.HasTile = true;
												break;
											case 3:
												tile.TileType = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.HasTile = true;
												break;
											case 4:
												tile.TileType = 51; //cobweb
												tile.HasTile = true;
												break;
											case 5:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>()); //chest
												break;
											case 6:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>()); //chest
												break;
											case 7:
												tile.TileType = 332; //gold coin
												tile.HasTile = true;
												break;
											case 8:
												tile.LiquidType = 1;
												tile.LiquidAmount = 255;

												if (confirmPlatforms == 0)
													tile.HasTile = false;

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.HasTile = false;
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0},
							{0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0},
							{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,1,0,2,0,0,0,0,0,3,0,0,0},
							{0,0,0,0,0,1,1,1,1,1,1,1,0,3,0,0,0},
							{0,4,4,5,6,6,7,7,7,7,7,6,6,6,5,4,0},
							{0,8,5,5,5,7,7,7,7,7,7,7,5,5,5,9,0},
							{0,0,0,8,5,5,5,5,5,5,5,5,5,9,0,0,0},
							{0,3,0,0,0,8,5,5,5,5,5,9,0,0,0,0,0},
							{0,3,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0},
							{0,3,0,0,0,0,0,0,0,0,0,0,0,0,3,0,3},
							{6,6,0,3,0,0,0,0,0,0,0,0,3,0,3,6,6},
							{7,6,6,6,0,3,0,0,0,0,0,0,3,6,6,6,7},
							{7,7,7,6,6,3,0,0,0,0,0,0,6,6,7,7,7},
							{7,7,7,7,6,6,0,0,0,0,0,6,6,7,7,7,7}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 1:
												tile.HasTile = true;
												tile.TileType = (ushort)ModContent.TileType<PyramidSlabTile>();
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 2:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<PyramidChestTile>(), true, true, -1, 0);
												}
												break;
											case 3:
												tile.HasTile = true;
												tile.TileType = 170;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 4:
												tile.HasTile = true;
												tile.TileType = 189;
												tile.Slope = 0;
												tile.IsHalfBlock = true;
												break;
											case 5:
												tile.HasTile = true;
												tile.TileType = 189;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 6:
												tile.HasTile = true;
												tile.TileType = 2;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 7:
												tile.HasTile = true;
												tile.TileType = 0;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 8:
												tile.HasTile = true;
												tile.TileType = 189;
												tile.Slope = (SlopeType)4;
												tile.IsHalfBlock = false;
												break;
											case 9:
												tile.HasTile = true;
												tile.TileType = 189;
												tile.Slope = (SlopeType)3;
												tile.IsHalfBlock = false;
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,3,0,0,0,0,0,0,0,0,0,0,4,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0},
							{0,0,0,0,0,0,0,0,5,0,0,0,0,0,7,8,9},
							{10,0,0,11,12,12,0,13,13,13,0,0,6,0,14,8,9},
							{10,10,11,15,0,0,0,0,0,0,0,0,8,16,0,8,9},
							{10,12,15,11,12,17,0,0,0,0,0,0,8,8,0,8,9},
							{12,15,0,12,12,12,0,0,0,0,0,0,8,8,0,8,8},
							{12,0,0,12,10,12,0,0,0,0,0,9,8,8,0,0,8},
							{12,18,0,12,20,10,0,0,0,0,0,9,20,8,19,0,8},
							{12,12,12,12,10,10,0,0,0,0,0,9,8,8,8,8,8}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.HasTile = false;
													tile.IsHalfBlock = false;
													tile.Slope = 0;
												}
												break;
											case 1:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 240, true, true, -1, 12);
												}
												break;
											case 2:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 240, true, true, -1, 13);
												}
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 242, true, true, -1, 13);
												}
												break;
											case 4:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 242, true, true, -1, 8);
												}
												break;
											case 5:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, 243, true, true, -1, 0);
												}
												break;
											case 6:
												tile.HasTile = true;
												tile.TileType = 25;
												tile.Slope = 0;
												tile.IsHalfBlock = true;
												break;
											case 7:
												tile.HasTile = true;
												tile.TileType = 25;
												tile.Slope = (SlopeType)2;
												tile.IsHalfBlock = false;
												break;
											case 8:
												tile.HasTile = true;
												tile.TileType = 25;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 9:
												tile.HasTile = true;
												tile.TileType = 23;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 10:
												tile.HasTile = true;
												tile.TileType = 199;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 11:
												tile.HasTile = true;
												tile.TileType = 203;
												tile.Slope = (SlopeType)2;
												tile.IsHalfBlock = false;
												break;
											case 12:
												tile.HasTile = true;
												tile.TileType = 203;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 13:
												if (confirmPlatforms == 0)
													tile.HasTile = false;
												WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
											case 14:
												tile.HasTile = true;
												tile.TileType = 25;
												tile.Slope = (SlopeType)4;
												tile.IsHalfBlock = false;
												break;
											case 15:
												tile.HasTile = true;
												tile.TileType = 203;
												tile.Slope = (SlopeType)3;
												tile.IsHalfBlock = false;
												break;
											case 16:
												tile.HasTile = true;
												tile.TileType = 25;
												tile.Slope = (SlopeType)1;
												tile.IsHalfBlock = false;
												break;
											case 17:
												tile.HasTile = true;
												tile.TileType = 203;
												tile.Slope = (SlopeType)1;
												tile.IsHalfBlock = false;
												break;
											case 18:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<CrystalStatue>(), true, true, -1, 0);
												}
												break;
											case 19:
												if (confirmPlatforms == 1)
												{
													tile.HasTile = false;
													tile.Slope = 0;
													tile.IsHalfBlock = false;
													WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<ManaStatue>(), true, true, -1, 0);
												}
												break;
											case 20:
												tile.HasTile = true;
												tile.TileType = 0;
												tile.Slope = 0;
												tile.IsHalfBlock = false;
												break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		public static void GenerateInfection(Vector2 pos, Mod mod, bool item = false)
		{
			int[] sumRolls = new int[11];
			int[] sumRolls2 = new int[9];
			int i = (int)pos.X / 16;
			int j = (int)pos.Y / 16;
			int i2 = i;
			int amt = 1;
			if (item)
				amt = WorldGen.genRand.Next(2) + 2;
			for (int k = 0; k < amt; k++)
			{
				sumRolls = new int[11];
				sumRolls2 = new int[9];
				Tile tileCenter = Framing.GetTileSafely(i, j - 3);
				if (tileCenter.TileType == ModContent.TileType<PyramidSlabTile>() || item)
				{
					for (int k2 = 0; k2 < 30; k2++)
					{
						int rand = WorldGen.genRand.Next(5);
						int rand2 = WorldGen.genRand.Next(4);
						int rand3 = WorldGen.genRand.Next(4);
						int sum = rand + rand2 + rand3;
						if (sumRolls[sum] < 9)
						{
							sumRolls[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls[k2] + 1; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 5, j - k3 - 3);
							if (!WorldGen.genRand.NextBool(40) && (tile.TileType == ModContent.TileType<PyramidSlabTile>() || (!tile.HasTile && (tile.WallType == ModContent.WallType<UnsafePyramidWallWall>() || tile.WallType == ModContent.WallType<UnsafePyramidBrickWallWall>()))))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 5, j - k3 - 3, (ushort)ModContent.TileType<CursedHive>());
								tile.TileType = (ushort)ModContent.TileType<CursedHive>();
								tile.HasTile = true;
							}
						}
					}
					for (int k2 = 0; k2 < 20; k2++)
					{
						int rand = WorldGen.genRand.Next(5);
						int rand2 = WorldGen.genRand.Next(5);
						int sum = rand + rand2;
						if (sumRolls2[sum] < 3)
						{
							sumRolls2[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls2.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls2[k2]; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 4, j + k3 - 2);
							if (!WorldGen.genRand.NextBool(20) && (tile.TileType == ModContent.TileType<PyramidSlabTile>() || (!tile.HasTile && (tile.WallType == ModContent.WallType<UnsafePyramidWallWall>() || tile.WallType == ModContent.WallType<UnsafePyramidBrickWallWall>()))))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 4, j + k3 - 2, (ushort)ModContent.TileType<CursedHive>());
								tile.TileType = (ushort)ModContent.TileType<CursedHive>();
								tile.HasTile = true;
							}
						}
					}
				}
				sumRolls = new int[11];
				sumRolls2 = new int[9];
				tileCenter = Framing.GetTileSafely(i, j + 3);
				if (tileCenter.TileType == ModContent.TileType<PyramidSlabTile>() || item)
				{
					for (int k2 = 0; k2 < 30; k2++)
					{
						int rand = WorldGen.genRand.Next(5);
						int rand2 = WorldGen.genRand.Next(4);
						int rand3 = WorldGen.genRand.Next(4);
						int sum = rand + rand2 + rand3;
						if (sumRolls[sum] < 9)
						{
							sumRolls[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls[k2] + 1; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 5, j + k3 + 3);
							if (!WorldGen.genRand.NextBool(40) && (tile.TileType == ModContent.TileType<PyramidSlabTile>() || (!tile.HasTile && (tile.WallType == ModContent.WallType<UnsafePyramidWallWall>() || tile.WallType == ModContent.WallType<UnsafePyramidBrickWallWall>()))))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 5, j + k3 + 3, (ushort)ModContent.TileType<CursedHive>());
								tile.TileType = (ushort)ModContent.TileType<CursedHive>();
								tile.HasTile = true;
							}
						}
					}
					for (int k2 = 0; k2 < 20; k2++)
					{
						int rand = WorldGen.genRand.Next(5);
						int rand2 = WorldGen.genRand.Next(5);
						int sum = rand + rand2;
						if (sumRolls2[sum] < 3)
						{
							sumRolls2[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls2.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls2[k2]; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 4, j - k3 + 2);
							if (!WorldGen.genRand.NextBool(20) && (tile.TileType == ModContent.TileType<PyramidSlabTile>() || (!tile.HasTile && (tile.WallType == ModContent.WallType<UnsafePyramidWallWall>() || tile.WallType == ModContent.WallType<UnsafePyramidBrickWallWall>()))))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 4, j - k3 + 2, (ushort)ModContent.TileType<CursedHive>());
								tile.TileType = (ushort)ModContent.TileType<CursedHive>();
								tile.HasTile = true;
							}
						}
					}
				}
				i = WorldGen.genRand.Next(-30, 31) + i2;
			}
		}
		public static void GeneratePyramidCrystalRoom(Mod mod, int spawnX, int spawnY)
		{
			int i;
			int j;
			float deg = WorldGen.genRand.Next(360);
			for (int k = 0; k < 3; k++)
			{
				Vector2 offset = new Vector2(k * 4 + WorldGen.genRand.Next(2 + 4 * k), 0).RotatedBy(MathHelper.ToRadians(deg));
				offset.Y *= 0.8f;
				i = spawnX + (int)offset.X;
				j = spawnY + (int)offset.Y;
				GeneratePyramidOval(mod, i, j, 12 + WorldGen.genRand.Next(10 - k * 2), 10 + WorldGen.genRand.Next(8 - k * 2));
				deg += WorldGen.genRand.Next(120);
			}
		}
		public static void GeneratePyramidSquare(Mod mod, int spawnX, int spawnY, int halfLength)
		{
			for (int i = -halfLength; i <= halfLength; i++)
			{
				for (int j = -halfLength; j <= halfLength; j++)
				{
					Tile tile = Framing.GetTileSafely(spawnX + i, spawnY + j);
					if (tile.WallType != ModContent.WallType<UnsafePyramidWallWall>() && tile.WallType != ModContent.WallType<UnsafeCursedTumorWallWall>() && tile.TileType != ModContent.TileType<CursedTumorTile>() && tile.TileType != ModContent.TileType<CursedHive>())
					{
						if (i != halfLength && i != -halfLength && j != halfLength && j != -halfLength)
							tile.WallType = (ushort)ModContent.WallType<UnsafePyramidWallWall>();
						SetTilePyramid(tile);
					}
				}
			}
		}
		public static void GeneratePyramidPath(Mod mod, int spawnX, int spawnY, int endX, int endY, int direction = 1, int max = 20, bool surround = false)
		{
			Vector2 start = new Vector2(spawnX, spawnY);
			Vector2 end = new Vector2(endX, endY);
			float lengthToEnd = Vector2.Distance(start, end) * 0.5f;
			float rotationToEnd = (start - end).ToRotation();
			Vector2 midPoint = (start + end) * 0.5f;
			spawnX = (int)midPoint.X;
			spawnY = (int)midPoint.Y;
			float yDistMult = WorldGen.genRand.NextFloat(0.25f, 1.00f) * direction;
			if (surround)
			{
				for (int i = 0; i < max; i++)
				{
					Vector2 circularLocation = new Vector2(lengthToEnd, 0).RotatedBy(MathHelper.ToRadians(i * (180f / max)));
					circularLocation.Y *= yDistMult;
					circularLocation = circularLocation.RotatedBy(rotationToEnd);
					GeneratePyramidSquare(mod, spawnX + (int)circularLocation.X, spawnY + (int)circularLocation.Y, 14);
				}
				GeneratePyramidSquare(mod, endX, endY, 32);
			}
			for (int i = 0; i < max; i++)
			{
				Vector2 circularLocation = new Vector2(lengthToEnd, 0).RotatedBy(MathHelper.ToRadians(i * (180f / max)));
				circularLocation.Y *= yDistMult;
				circularLocation = circularLocation.RotatedBy(rotationToEnd);
				GeneratePyramidOval(mod, spawnX + (int)circularLocation.X, spawnY + (int)circularLocation.Y, 6, 6, 0.75f);
			}
			GeneratePyramidCrystalRoom(mod, endX, endY);
			for (int j = -3; j <= -1; j++)
				for (int i = j; i <= -j; i++)
				{
					Tile tile = Framing.GetTileSafely(endX + i, endY + j + 4);
					tile.TileType = (ushort)ModContent.TileType<CursedTumorTile>();
					tile.HasTile = true;
				}
			WorldGen.PlaceTile(endX, endY, ModContent.TileType<RubyKeystoneTile>(), false, true);
		}
		public static void GeneratePyramidOval(Mod mod, int spawnX, int spawnY, int radius = 14, int radiusY = 14, float thickMult = 1f, int radiusConversion = 5, bool extraRestriction = false)
		{
			float scale = radiusY / (float)radius;
			float invertScale = (float)radius / radiusY;
			for (int x = -radius; x <= radius; x++)
			{
				for (float y = -radius; y <= radius; y += (invertScale * 0.85f))
				{
					float radialMod = WorldGen.genRand.NextFloat(2.5f, 4.5f) * thickMult;
					if (Math.Sqrt(x * x + y * y) <= radius + 0.5)
					{
						int xPosition6 = spawnX + x;
						int yPosition6 = spawnY + (int)(y * scale);
						Tile tile = Framing.GetTileSafely(xPosition6, yPosition6);
						bool capable = true;
						if (tile.WallType == ModContent.WallType<UnsafePyramidWallWall>() && !tile.HasTile)
							capable = false;
						bool valid = !extraRestriction || (tile.TileType == ModContent.TileType<PyramidBrickTile>() || tile.TileType == ModContent.TileType<PyramidSlabTile>()
							|| tile.TileType == ModContent.TileType<CursedHive>() || tile.TileType == (ushort)ModContent.TileType<AncientGoldSpikeTile>() || tile.TileType == (ushort)ModContent.TileType<RoyalGoldBrickTile>()
							|| Main.tileSand[tile.TileType]);
						if (Math.Sqrt(x * x + y * y) >= radius - radialMod && tile.WallType != ModContent.WallType<UnsafeCursedTumorWallWall>() && capable)
						{
							ConvertNearbyTiles(mod, xPosition6, yPosition6, radiusConversion);
							if (tile.TileType == ModContent.TileType<TrueSandstoneTile>() || tile.WallType == ModContent.WallType<TrueSandstoneWallWall>() || tile.TileType == ModContent.TileType<AncientGoldGateTile>())
								valid = false;
							if (valid && (tile.HasTile || (tile.WallType != ModContent.WallType<TrueSandstoneWallWall>() && tile.WallType != ModContent.WallType<UnsafePyramidWallWall>())) && Main.tileSolid[tile.TileType])
							{
								tile.TileType = (ushort)ModContent.TileType<CursedTumorTile>();
								tile.HasTile = true;
							}
						}
						else if (tile.WallType != ModContent.WallType<TrueSandstoneWallWall>() && (valid || !tile.HasTile))
						{
							tile.WallType = (ushort)ModContent.WallType<UnsafeCursedTumorWallWall>();
							tile.HasTile = false;
						}
					}
				}
			}
		}
		public static void ConvertNearbyTiles(Mod mod, int spawnX, int spawnY, int radius = 5)
		{
			for (int x = -radius; x <= radius; x++)
			{
				for (int y = -radius; y <= radius; y++)
				{
					if (Math.Sqrt(x * x + y * y) <= radius + 0.5)
					{
						int xPosition6 = spawnX + x;
						int yPosition6 = spawnY + y;
						Tile tile = Framing.GetTileSafely(xPosition6, yPosition6);
						if (tile.HasTile && WorldGen.genRand.NextBool((int)Math.Sqrt(x * x + y * y) + 2) && (tile.TileType == (ushort)ModContent.TileType<PyramidSlabTile>() || tile.TileType == (ushort)ModContent.TileType<RuinedPyramidBrickTile>()))
						{
							tile.TileType = (ushort)ModContent.TileType<CursedHive>();
							tile.HasTile = true;
						}
					}
				}
			}
		}
		/*public static void DoMalditeGeneration(int i, int j)
		{
			int rand = WorldGen.genRand.Next(2) + 2;
			for (int rep = 0; rep < rand; rep++)
			{
				int tileX = i + WorldGen.genRand.Next(6 * rep);
				int tileY = j + WorldGen.genRand.Next(6 * rep);
				int radiusMaldite = 10 + WorldGen.genRand.Next(5) - rep * 3;
				for (int x = -radiusMaldite; x <= radiusMaldite; x++)
				{
					for (int y = -radiusMaldite; y <= radiusMaldite; y++)
					{
						int malditePosX = tileX + x;
						int malditePosY = tileY + y;
						float distFromCenter = (float)Math.Sqrt(x * x + y * y);
						int distRand = (int)distFromCenter;
						if (distFromCenter <= radiusMaldite + 0.5f && WorldGen.genRand.Next(100) > 2 + distRand * 2)
						{
							Tile tileRad = Framing.GetTileSafely(malditePosX, malditePosY);
							bool capable = tileRad.TileType == ModContent.TileType<CursedTumorTile>();
							if (tileRad.HasTile && capable)
							{
								tileRad.TileType = (ushort)ModContent.TileType<MalditeTile>();
								tileRad.WallType = (ushort)ModContent.WallType<UnsafeMalditeWallWall>();
								tileRad.HasTile = true;
							}
							else if (tileRad.WallType == ModContent.WallType<UnsafeCursedTumorWallWall>())
							{
								tileRad.WallType = (ushort)ModContent.WallType<UnsafeMalditeWallWall>();
							}
						}
					}
				}
			}
		}*/
		public static void DoAltBlocksGeneration(int i, int j, int size, bool rubble = false)
		{
			int tileX = i + WorldGen.genRand.Next(5);
			int tileY = j + WorldGen.genRand.Next(5);
			int radiusAlt = size + WorldGen.genRand.Next(4);
			int sizeX = radiusAlt;
			int sizeY = sizeX;
			float sizeYMod = WorldGen.genRand.NextFloat(0.55f, 0.85f);
			for (int x = -sizeX; x <= sizeX; x++)
			{
				for (float y = -sizeY; y <= sizeY; y += 0.66f)
				{
					int PosX = tileX + x;
					int PosY = tileY + (int)(y * sizeYMod + 0.5f);
					float distFromCenter = (float)Math.Sqrt(x * x + y * sizeYMod * y * sizeYMod);
					if (distFromCenter <= radiusAlt + (size / 20f) + 0.5f && WorldGen.genRand.Next(size + 4) + 2 > distFromCenter * 1f)
					{
						Tile tileRad = Framing.GetTileSafely(PosX, PosY);
						bool capable = tileRad.TileType == ModContent.TileType<RuinedPyramidBrickTile>();
						if (rubble && tileRad.HasTile && capable && WorldGen.genRand.Next(size + 4) > distFromCenter * 1f && !WorldGen.genRand.NextBool(4))
						{
							tileRad.TileType = (ushort)ModContent.TileType<PyramidRubbleTile>();
							//if (!WorldGen.genRand.NextBool(4) && tileRad.WallType == ModContent.WallType<UnsafePyramidWallWall>())
							//tileRad.WallType = (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>();
							tileRad.HasTile = true;
						}
						else
						{
							capable = tileRad.TileType == ModContent.TileType<PyramidSlabTile>();
							if (tileRad.HasTile && capable)
							{
								tileRad.TileType = (ushort)ModContent.TileType<RuinedPyramidBrickTile>();
								//if (WorldGen.genRand.NextBool(4) && tileRad.WallType == ModContent.WallType<UnsafePyramidWallWall>())
								//tileRad.WallType = (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>();
								tileRad.HasTile = true;
							}
						}
					}
				}
			}
		}
	}
}